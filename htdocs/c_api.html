<!DOCTYPE html>
<html lang="en">
<head itemscope>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="description" content="A fast lightweight NoSQL shared memory database library written in C">
<meta name="author" content="Tanel Tammet, Priit JÃ¤rv">
<meta name="keywords" content="database, library, main memory, shared memory, speed, NoSQL" /> 

<meta itemprop="itemtype" content="http://schema.org/SoftwareApplication" />
<meta itemprop="name" content="WhiteDB" />
<meta itemprop="description" content="WhiteDB is a fast, lightweight NoSQL shared memory database library written in C." />
<meta itemprop="url" content="http://www.whitedb.org" />
<meta itemprop="operatingSystems" content="Linux, Windows" />
<meta itemprop="softwareApplicationCategory" content="DeveloperApplication" />

<meta property="og:title" content="WhiteDB"/> 
<meta property="og:url" content="http://www.whitedb.org"/> 
<meta property="og:site_name" content="WhiteDB"/> 
<meta property="og:type" content="website"/>
<meta property="og:description" content="A fast lightweight NoSQL shared memory database library written in C."/>
<meta property="fb:admins" content="tanel.tammet"/>

<link rel="shortcut icon" href="img/logo2.png">

<title>Whitedb</title>
<!--
<link href='http://fonts.googleapis.com/css?family=Roboto:300' rel='stylesheet' type='text/css'>
-->
<!-- Bootstrap core CSS -->
<link href="css/bootstrap.min.css" rel="stylesheet">
<!-- Custom styles for this template -->
<link href="css/wdb.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script src="js/html5shiv.js"></script>
  <script src="js/respond.min.js"></script>
<![endif]-->
<!--  
<style type="text/css"></style>
-->
<!-- <script src="js/jquery.js"></script> -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script>

function setleftmenu() {
  var d;
  d=$("#maincontainer").offset();
  if (d && d.left && d.left>10) {
    $("#sidemenu").css("left",""+d.left-300);    
  }    
}

function shortenmenu(){
 $('#sidemenu a').each(function(){
    $(this).text($(this).text().substring(2));
 });
}

/*
function onscroll() {
  var d2;
  d2=window.pageYOffset;
  //console.log(d2);
  if (!d2) $("#sidemenu").css("top",""+84);
  else {
    if (d2>74) {
      $("#sidemenu").css("top","10");
    } else {
      $("#sidemenu").css("top",""+84-d2);
    }  
  }      
}
*/

$(document).ready(function(){  
  shortenmenu();
  setleftmenu();
	$("dt").click(function(){
		if(!$(this).hasClass("xopen")) {
      $(this).addClass("xopen");
      $(this).next().find("dl").slideDown(400);
			//$(this).next().find("dl").css("display","block");      
		} else {
      $(this).removeClass("xopen");
      $(this).next().find("dl").slideUp(400);
      //$(this).next().find("dl").css("display","none");      
    }        
	});
  $(window).resize(function() {
    setleftmenu();
  });
})

</script>
</head>

<body>

<div id="fb-root"></div>

<div class="navbar navbar-inverse navbar-static-top" style="background-color: #333333;">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img class="logo" src="img/logo1.png"/>WhiteDB</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dummy"><a href="index.html">Home</a></li>        
        <li class="dummy"><a href="tutorial.html">Tutorial</a></li>
        <li class="dummy"><a href="speed.html">Speed</a></li>
        <!-- <li class="dummy"><a href="scenarios.html">Scenarios</a></li> -->
        <li class="dummy"><a href="c_api.html">C API</a></li>        
        <li class="dummy"><a href="python_api.html">Python</a></li> 
        <li class="dummy"><a href="tools.html">Tools</a></li>
        <li class="dummy"><a href="download.html">Download</a></li>
        <li class="dummy"><a href="install.html">Install</a></li>
        <li class="dummy"><a href="licence.html">Licence</a></li>
        <li class="dummy"><a href="contact.html">Contact</a></li>        
      </ul>
    </div><!--/.navbar-collapse -->
  </div>
</div>

<!-- content after titlebar -->

<!-- jumbotron for a primary message  -->

<div class="jumbotron" id="jumbotron">
  <div class="container" style="text-align: left">
    <h1 class="jumbotron_title">C API</h1>
    <p class="jumbotron_caption">API docs and installation manual
    </p>
  </div>  
</div>

<!-- sidemenu for large screens -->

<div id="sidemenu" class="hidden-print sidemenu" role="complementary">
<div class="isidemenu">  
<h3 class="menutitle">Contents</h3>
<dl class="toc"><dt><span class="section"><a href="#_principles_and_goals">1. Principles and goals</a></span></dt><dt><span class="section"><a href="#_obtaining_and_licence">2. Obtaining and licence</a></span></dt><dt><span class="section"><a href="#_using_whitedb_in_applications">3. Using WhiteDB in applications</a></span></dt><dd><dl><dt><span class="section"><a href="#anchor-3">3.1. Compiling and linking against WhiteDB installation</a></span></dt><dt><span class="section"><a href="#anchor-4">3.2. Dynamic linking under Windows</a></span></dt><dt><span class="section"><a href="#anchor-5">3.3. Compiling with database source files</a></span></dt></dl></dd><dt><span class="section"><a href="#_database_api">4. Database API</a></span></dt><dd><dl><dt><span class="section"><a href="#_preliminaries">4.1. Preliminaries</a></span></dt><dt><span class="section"><a href="#_checks_and_errors">4.2. Checks and errors</a></span></dt><dt><span class="section"><a href="#_creating_and_deleting_the_database">4.3. Creating and deleting the database</a></span></dt><dt><span class="section"><a href="#_creating_deleting_scanning_records">4.4. Creating, deleting, scanning records</a></span></dt><dt><span class="section"><a href="#_setting_and_reading_record_fields">4.5. Setting and reading record fields</a></span></dt><dt><span class="section"><a href="#anchor-1">4.6. Encoding and decoding data stored in the record fields</a></span></dt><dt><span class="section"><a href="#_dumping_and_restoring_database_contents_to_from_disk">4.7. Dumping and restoring database contents to/from disk</a></span></dt><dt><span class="section"><a href="#_read_and_write_locking_the_database_for_concurrency_control">4.8. Read and write locking the database for concurrency control</a></span></dt><dt><span class="section"><a href="#_writing_safely_without_a_write_lock">4.9. Writing safely without a write lock</a></span></dt><dt><span class="section"><a href="#_semi_structured_data">4.10. Semi-structured data</a></span></dt><dt><span class="section"><a href="#_utilities">4.11. Utilities</a></span></dt><dt><span class="section"><a href="#anchor-6">4.12. Query functions</a></span></dt><dt><span class="section"><a href="#_child_databases">4.13. Child databases</a></span></dt><dt><span class="section"><a href="#_getting_information_about_the_database_state">4.14. Getting information about the database state</a></span></dt></dl></dd><dt><span class="section"><a href="#_rdf_parsing_exporting_api">5. RDF parsing / exporting API</a></span></dt><dt><span class="section"><a href="#_index_api">6. Index API</a></span></dt><dd><dl><dt><span class="section"><a href="#_examples">6.1. Examples</a></span></dt></dl></dd></dl>
</div>
</div>

<!-- main content -->

<div class="container" id="maincontainer">
  <div class="row">
     <div class="col-md-12 wblock wblock1">
      <div class="wiblock wiblock_full">      
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="#_principles_and_goals">1. Principles and goals</a></span></dt><dt><span class="section"><a href="#_obtaining_and_licence">2. Obtaining and licence</a></span></dt><dt><span class="section"><a href="#_using_whitedb_in_applications">3. Using WhiteDB in applications</a></span></dt><dd><dl><dt><span class="section"><a href="#anchor-3">3.1. Compiling and linking against WhiteDB installation</a></span></dt><dt><span class="section"><a href="#anchor-4">3.2. Dynamic linking under Windows</a></span></dt><dt><span class="section"><a href="#anchor-5">3.3. Compiling with database source files</a></span></dt></dl></dd><dt><span class="section"><a href="#_database_api">4. Database API</a></span></dt><dd><dl><dt><span class="section"><a href="#_preliminaries">4.1. Preliminaries</a></span></dt><dt><span class="section"><a href="#_checks_and_errors">4.2. Checks and errors</a></span></dt><dt><span class="section"><a href="#_creating_and_deleting_the_database">4.3. Creating and deleting the database</a></span></dt><dt><span class="section"><a href="#_creating_deleting_scanning_records">4.4. Creating, deleting, scanning records</a></span></dt><dt><span class="section"><a href="#_setting_and_reading_record_fields">4.5. Setting and reading record fields</a></span></dt><dt><span class="section"><a href="#anchor-1">4.6. Encoding and decoding data stored in the record fields</a></span></dt><dt><span class="section"><a href="#_dumping_and_restoring_database_contents_to_from_disk">4.7. Dumping and restoring database contents to/from disk</a></span></dt><dt><span class="section"><a href="#_read_and_write_locking_the_database_for_concurrency_control">4.8. Read and write locking the database for concurrency control</a></span></dt><dt><span class="section"><a href="#_writing_safely_without_a_write_lock">4.9. Writing safely without a write lock</a></span></dt><dt><span class="section"><a href="#_semi_structured_data">4.10. Semi-structured data</a></span></dt><dt><span class="section"><a href="#_utilities">4.11. Utilities</a></span></dt><dt><span class="section"><a href="#anchor-6">4.12. Query functions</a></span></dt><dt><span class="section"><a href="#_child_databases">4.13. Child databases</a></span></dt><dt><span class="section"><a href="#_getting_information_about_the_database_state">4.14. Getting information about the database state</a></span></dt></dl></dd><dt><span class="section"><a href="#_rdf_parsing_exporting_api">5. RDF parsing / exporting API</a></span></dt><dt><span class="section"><a href="#_index_api">6. Index API</a></span></dt><dd><dl><dt><span class="section"><a href="#_examples">6.1. Examples</a></span></dt></dl></dd></dl>
</div> <!-- inner toc end -->
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_principles_and_goals"></a>1.Â Principles and goals</h2></div></div></div><p>WhiteDB is a lightweight database library operating fully in main memory.
Disk is used only for dumping/restoring database and logging.</p><p>Data is persistantly kept in the shared memory area: it is available simultaneously
to all processes and is kept intact even if no processes are currently using the
database.</p><p>WhiteDB has no server process. Data is read and written directly from/to memory,
no sockets are used between WhiteDB and the application using WhiteDB.</p><p>WhiteDB keeps data as N-tuples: each database record is a tuple of N elements.
Each element (record field) may have an arbitrary type amongst the types provided
by WhiteDB. Each record field contains exactly one integer (4 bytes or 8 bytes).
Datatypes which cannot be fit into one integer are allocated separately
and the record field contains an (encoded) pointer to the real data.</p><p>WhiteDB is written in pure C in a portable manner and should compile and function
without additional porting at least  under Linux (gcc) and Windows
(native Windows C compiler cl). It has Python and experimental Java bindings.</p><p>The Python bindings and their usage is explained in the separate manual
<a class="ulink" href="python_api.html" target="_top">Python API</a>.</p><p>WhiteDB has several goals:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
speed
</li><li class="listitem">
portability
</li><li class="listitem">
small footprint and low memory usage
</li><li class="listitem">
usability as an rdf database
</li><li class="listitem">
usability as an extended rdf database, xml database and outside these scopes
</li><li class="listitem">
integration with the Gandalf rule engine (work in progress)
</li></ul></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The name <span class="emphasis"><em>wgdb</em></span> is also used in some places, such as the name of loadable
modules and libraries. In documentation it may be used interchangeable with
WhiteDB, the letter <span class="emphasis"><em>G</em></span> refers to the Gandalf reasoner.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_obtaining_and_licence"></a>2.Â Obtaining and licence</h2></div></div></div><p>WhiteDB releases can be obtained from <a class="ulink" href="http://www.whitedb.org" target="_top">http://www.whitedb.org</a></p><p>The development version can be obtained from the source repository:
<a class="ulink" href="https://github.com/priitj/whitedb" target="_top">https://github.com/priitj/whitedb</a></p><p>WhiteDB is licensed under GPL version 3.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_using_whitedb_in_applications"></a>3.Â Using WhiteDB in applications</h2></div></div></div><p>See <span class="emphasis"><em>demo.c</em></span> and <span class="emphasis"><em>query.c</em></span> in the <span class="emphasis"><em>Examples</em></span> directory of the
distribution package for complete examples of basic database usage.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="anchor-3"></a>3.1.Â Compiling and linking against WhiteDB installation</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Include the API headers in your programs:
</li></ul></div><pre class="programlisting">#include &lt;whitedb/dbapi.h&gt;
#include &lt;whitedb/rdfapi.h&gt; /* only for using the raptor API */
#include &lt;whitedb/indexapi.h&gt; /* only for using the index API */</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Include -lwgdb to LDFLAGS in your Makefile or linker arguments
</li></ul></div><p>If you used a non-standard installation prefix, using -I and -L
compiler/linker flags is required as usual.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="anchor-4"></a>3.2.Â Dynamic linking under Windows</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Include the API headers
</li></ul></div><pre class="programlisting">#include &lt;dbapi.h&gt;
#include &lt;rdfapi.h&gt; /* only for using the raptor API */
#include &lt;indexapi.h&gt; /* only for using the index API */</pre><p>This requires providing the header file directory to the compiler.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
Compile and link against the library
</p><pre class="literallayout">cl.exe /I"..\whitedb-0.6\Db" yourprog.c ..\whitedb-0.6\wgdb.lib</pre></li></ul></div><p>This produces <span class="emphasis"><em>yourprog.exe</em></span> that requires <span class="emphasis"><em>wgdb.dll</em></span> to run.</p><p>The <span class="emphasis"><em>compile.bat</em></span> and Examples directory also contains compilation
examples.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="anchor-5"></a>3.3.Â Compiling with database source files</h3></div></div></div><p>See <span class="emphasis"><a href="code/compile_demo.sh">Examples/compile_demo.sh</a></span> (<span class="emphasis"><em>Examples\compile_demo.bat</em></span> under
Windows). This compiles the demo program <span class="emphasis"><em>demo.c</em></span> with the WhiteDB source
files.</p><p>These programs and scripts may be used as templates for creating
database applications.</p><p>Additionally, the shell script <span class="emphasis"><em>unite.sh</em></span> allows creation of an amalgamation,
resulting in two files: <span class="emphasis"><em>whitedb.c</em></span> and <span class="emphasis"><em>whitedb.h</em></span>. By including the source
file (<span class="emphasis"><em>whitedb.c</em></span>) with your application, you can effectively embed
whitedb without having to worry about source and header files en masse.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_database_api"></a>4.Â Database API</h2></div></div></div><p>The database API prototypes and macros are all found in the <span class="emphasis"><em>Db/dbapi.h</em></span> file.
You should include this single header file in all the files of your application
calling WhiteDB functions.</p><p>The database API has functions for:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
creating and deleting the database
</li><li class="listitem">
creating and deleting records
</li><li class="listitem">
setting and reading record fields
</li><li class="listitem">
encoding and decoding data stored in the record fields
</li><li class="listitem">
dumping and restoring database contents to/from disk
</li><li class="listitem">
read and write locking the database for concurrency control
</li></ul></div><p>It is a good idea to check the usage of API calls from the example program
<span class="emphasis"><em>Examples/demo.c</em></span></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_preliminaries"></a>4.1.Â Preliminaries</h3></div></div></div><p>All the API calls follow these principles:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
each function has a wg_ prefix.
</li><li class="listitem">
function names are all lower case, _ used as a separator
</li><li class="listitem">
each function takes the pointer to the database as a first argument.
</li></ul></div><p>The database pointer is obtained when creating a new database or attaching to
an existing one.</p><p>You can have several databases open at any time:
they will simply have different pointers. Observe that the pointer
you will get from two different processes for the same database will
be different.</p><p>The record pointer is returned when creating records or when fetching query
results. This <code class="literal">void *</code> type pointer points directly to the record data in the
shared memory segment and should be used with all the functions that read or
manipulate record fields. You can also encode a record pointer and write it
into another record, forming a link between records.</p><p>All the record fields are ordinary C integers (32 or 64 bytes).
In order to allow exact control over the integer length the datatype</p><p><code class="literal">wg_int</code></p><p>is used for all encoded data. This datatype is in normal usage
equivalent (typedef-d) to an int (or a 64-bit integer if the database
is configured as 64-bit).</p><p>Strings given to the API functions are ordinary 0-terminated C strings,
their length is an ordinary C string length as computed by strlen.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_checks_and_errors"></a>4.2.Â Checks and errors</h3></div></div></div><p>WhiteDB library performs a few checks for most library operations to ensure
sanity. Checking causes a very small speed penalty and can be disabled by
setting <span class="emphasis"><em>--disable-checking</em></span> during installation.</p><p>One of the standard checks is whether the database pointer passed as the
first argument is not NULL and the first segment of the database area
contains the specific integer indicating that the segment is actually
created as a WhiteDB database.</p><p>Whenever a field record is accessed, WhiteDB checks that the field number is
not larger than the record length. Validity checks are also performed during
data decoding and encoding.</p><p>In case WhiteDB recognizes an error, the API function called returns an error
value specified in the API doc. For example, failed record creation returns a
NULL pointer. A WG_ILLEGAL value is returned in case of encoding error, NULL
in case of string decoding errors, -1 in case of length decoding errors.</p><p>In addition to returning a specific error value, WhiteDB prints an error
message to stderr. In some cases the error message is a small error trace
through several layers of internal calls. Printing to stderr can be inhibited
by defining a macro WG_NO_ERRPRINT during WhiteDB compilation.</p><p>Notice that in error cases, nothing is printed to stdout (only stderr) and
WhiteDB does not exit: the corresponding API call returns an error value which
should be handled by the code calling the API function.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_creating_and_deleting_the_database"></a>4.3.Â Creating and deleting the database</h3></div></div></div><p>Functions:</p><pre class="programlisting">void* wg_attach_database(char* dbasename, wg_int size);
void* wg_attach_existing_database(char* dbasename);
void* wg_attach_logged_database(char* dbasename, wg_int size);
void* wg_attach_database_mode(char* dbasename, wg_int size, int mode);
void* wg_attach_logged_database_mode(char* dbasename, wg_int size, int mode);
int wg_detach_database(void* dbase);
int wg_delete_database(char* dbasename);

void* wg_attach_local_database(wg_int size);
void wg_delete_local_database(void* dbase);</pre><p>Details:</p><pre class="literallayout">void* wg_attach_database(char* dbasename, int size)</pre><p>Returns a pointer to the database, NULL if failure. Size in bytes.
Created database is a contiguous block of shared memory of
size bytes. It cannot be shrinked or extended later.</p><p>The returned pointer should be passed to all the WhiteDB API calls as
the first parameter.</p><p>Database name should be an integer.
The call wg_attach_database(NULL, 0) creates a database with a
default name ("1000") and default size 10000000 (10 megabytes).
Both defaults can be configured from <span class="emphasis"><em>Db/dbmem.h</em></span>.</p><p>If the size parameter is &gt; 0, the named shared memory segment exists and
it is smaller than the given size, the call returns NULL.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The typical default shared memory allocatable size of a linux system
is under 100 megabytes.
You can see the allocatable size in bytes by doing
<code class="literal">cat /proc/sys/kernel/shmmax</code>.
You can set the shared memory size by becoming root and doing
<code class="literal">echo shared_memory_size &gt; /proc/sys/kernel/shmmax</code>
where shared_memory_size is a number of bytes.</p></td></tr></table></div><pre class="literallayout">void* wg_attach_existing_database(char* dbasename)</pre><p>Like <code class="literal">wg_attach_database()</code>, but does not create a new database when no
database with name dbasename exists. In the latter case returns NULL.</p><pre class="literallayout">void* wg_attach_logged_database(char* dbasename, wg_int size)</pre><p>Like <code class="literal">wg_attach_database()</code>, but starts journal logging when the
database is initialized. If the named segment already exists and does
not have logging enabled, the function returns NULL.</p><pre class="literallayout">void* wg_attach_database_mode(char* dbasename, wg_int size, int mode)</pre><p>Like <code class="literal">wg_attach_database()</code>, but create the memory segment with the
given permissions. The parameter <code class="literal">mode</code> is the nine permission bits
(3 per user, group and others, usually given in octal. Example:
0660 gives the read-write permission to the user and group and
no permissions to others).</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>read-only permissions do not work. Also, this parameter has no
effect on the Windows platform currently.</p></td></tr></table></div><pre class="literallayout">void* wg_attach_logged_database_mode(char* dbasename, wg_int size, int mode)</pre><p>Like <code class="literal">wg_attach_logged_database()</code>, but create the memory segment with the
given permissions. See the function <code class="literal">wg_attach_database_mode()</code> for details.</p><pre class="literallayout">int wg_detach_database(void* dbase)</pre><p>Detaches a database: returns 0 if OK.
Exiting from the process detaches database automatically.</p><pre class="literallayout">int wg_delete_database(char* dbasename)</pre><p>Deletes a database: returns 0 if OK.
NB! Database is not deleted unless all processes who have previously
attached have detached from it and at least one process has made
a delete call.</p><pre class="literallayout">void* wg_attach_local_database(int size)</pre><p>Returns a pointer to local memory database, NULL if failure. Size
is given in bytes. The database is allocated in the private memory
of the process and will neither be readable to other processes nor
persist when the process closes.</p><p>In every other aspect the database behaves similarly to a shared
memory database.</p><pre class="literallayout">void wg_delete_local_database(void* dbase)</pre><p>Deletes a local memory database. Memory allocated for the database
will be freed.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_creating_deleting_scanning_records"></a>4.4.Â Creating, deleting, scanning records</h3></div></div></div><p>Functions:</p><pre class="programlisting">void* wg_create_record(void* db, wg_int length);
void* wg_create_raw_record(void* db, wg_int length);
wg_int wg_delete_record(void* db, void *rec);
void* wg_get_first_record(void* db);
void* wg_get_next_record(void* db, void* record);
void *wg_get_first_parent(void* db, void *record);
void *wg_get_next_parent(void* db, void* record, void *parent);</pre><p>Details:</p><pre class="literallayout">void* wg_create_record(void* db, wg_int length)</pre><p>Creates a new record of length length and initialises all fields
to 0 (used as a NULL value in WhiteDB).
Returns NULL when error, ptr to record otherwise.</p><pre class="literallayout">void* wg_create_raw_record(void* db, wg_int length)</pre><p>Same as wg_create_record(), except the initial field values
are not indexed. Use together with wg_set_new_field().</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>using this together with index templates has complex and probably
unexpected consequences. Not recommended.</p></td></tr></table></div><pre class="literallayout">wg_int wg_delete_record(void* db, void *rec)</pre><p>Deletes a record with a pointer rec.
Returns 0 if OK, non-0 on error.
You should not worry about deallocation of data in the record
fields: this is done automatically.</p><pre class="literallayout">void* wg_get_first_record(void* db)</pre><p>Returns first record pointer, NULL when error or no records available.</p><pre class="literallayout">void* wg_get_next_record(void* db, void* record)</pre><p>Returns next record pointer, NULL when error or no records available.
record parameter is a pointer to the (previous) record.</p><pre class="literallayout">void *wg_get_first_parent(void* db, void *record)</pre><p>Return the first parent of the record. Record A is a parent of record B if
record A contains a link to record B. Records may have more than one parent.
Consult <a class="xref" href="#anchor-1" title="4.6.Â Encoding and decoding data stored in the record fields">SectionÂ 4.6, âEncoding and decoding data stored in the record fieldsâ</a>
on how to link records.</p><p>Returns the pointer to the first parent record or NULL if there are no
parents or when the database is not configured to track parents.</p><pre class="literallayout">void *wg_get_next_parent(void* db, void* record, void *parent)</pre><p>Return the next parent of the record. The argument <span class="emphasis"><em>parent</em></span> is a record
returned by a previous call of <code class="literal">wg_get_first_parent()</code> or
<code class="literal">wg_get_next_parent()</code>. Returns NULL if there are no more parent records.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>the current implementation of this function can be slow if there are
many parents to a record.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_setting_and_reading_record_fields"></a>4.5.Â Setting and reading record fields</h3></div></div></div><p>Functions:</p><pre class="programlisting">wg_int wg_get_record_len(void* db, void* record);

wg_int wg_set_field(void* db, void* record, wg_int fieldnr, wg_int data);
wg_int wg_set_new_field(void* db, void* record, wg_int fieldnr, wg_int data);

wg_int wg_get_field(void* db, void* record, wg_int fieldnr);
wg_int wg_get_field_type(void* db, void* record, wg_int fieldnr);

wg_int wg_set_int_field(void* db, void* record, wg_int fieldnr, wg_int data);
wg_int wg_set_double_field(void* db, void* record, wg_int fieldnr, double data);
wg_int wg_set_str_field(void* db, void* record, wg_int fieldnr, char* data);

wg_int* wg_field_addr(void* db, void* record, wg_int fieldnr);</pre><p>Details:</p><pre class="literallayout">wg_int wg_get_record_len(void* db, void* record)</pre><p>Gives record length (0,â¦). Returns negative int when error.</p><pre class="literallayout">wg_int wg_set_field(void* db, void* record, wg_int fieldnr, wg_int data)</pre><p>Sets field fieldnr value to encoded data. Field numbers start from 0.
Passed data must be 0 (NULL value) or encoded (see <a class="xref" href="#anchor-1" title="4.6.Â Encoding and decoding data stored in the record fields">SectionÂ 4.6, âEncoding and decoding data stored in the record fieldsâ</a>).
Returns negative int when err, 0 when ok.</p><p>Do not worry about deallocating earlier data in the field: this is done
automatically.</p><pre class="literallayout">wg_int wg_set_new_field(void* db, void* record, wg_int fieldnr, wg_int data)</pre><p>Same as wg_set_field() except it can only be used to write the contents
of newly created fields that do not have values. Writing will be somewhat
faster than with wg_set_field(). It is the responsibility of the caller
to ensure that the field to be written really is one that contains no earlier
data. Use together with wg_create_raw_record().</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>using this together with index templates has complex and probably
unexpected consequences. Not recommended.</p></td></tr></table></div><pre class="literallayout">wg_int wg_get_field(void* db, void* record, wg_int fieldnr)</pre><p>Returns encoded data in field fieldnr. Data should be decoded later for ordinary use,
see <a class="xref" href="#anchor-1" title="4.6.Â Encoding and decoding data stored in the record fields">SectionÂ 4.6, âEncoding and decoding data stored in the record fieldsâ</a>.</p><pre class="literallayout">wg_int wg_get_field_type(void* db, void* record, wg_int fieldnr)</pre><p><a id="anchor-2"></a>Returns datatype in field fieldnr. Datatypes are defined by these macros, avoid
using corresponding numbers, since these may change:</p><pre class="programlisting">#define WG_NULLTYPE 1
#define WG_RECORDTYPE 2
#define WG_INTTYPE 3
#define WG_DOUBLETYPE 4
#define WG_STRTYPE 5
#define WG_XMLLITERALTYPE 6
#define WG_URITYPE 7
#define WG_BLOBTYPE 8
#define WG_CHARTYPE 9
#define WG_FIXPOINTTYPE 10
#define WG_DATETYPE 11
#define WG_TIMETYPE 12</pre><p>The following are convenience functions for common datatypes:</p><pre class="literallayout">wg_int wg_set_int_field(void* db, void* record, wg_int fieldnr, wg_int data)</pre><p>Like wg_set_field but automatically encodes data: pass ordinary integer.</p><pre class="literallayout">wg_int wg_set_double_field(void* db, void* record, wg_int fieldnr, double data)</pre><p>Like wg_set_field but automatically encodes data: pass ordinary double.</p><pre class="literallayout">wg_int wg_set_str_field(void* db, void* record, wg_int fieldnr, char* data)</pre><p>Like wg_set_field but automatically encodes data: pass ordinary null-terminated string.</p><p>The following is a macro returning an address (C pointer) of a field:</p><pre class="literallayout">wg_int* wg_field_addr(void* db, void* record, wg_int fieldnr)</pre><p>Avoid wg_field_addr in normal cases: use wg_get_field and wg_set_field instead.
The wg_field_addr macro performs no checks whatsoever: it is useful only for achieving maximum
speed. While it is safe to read a value from the address returned, use it with extreme caution
when storing data to the field. It is OK to directly store an encoded value to the field only if it
currently contains an immediate value (immediates are NULL, short integer, date, time, char),
is not indexed and no logging is used.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="anchor-1"></a>4.6.Â Encoding and decoding data stored in the record fields</h3></div></div></div><p>The general principle of data storage in records is that each datatype has
to be encoded before storage and decoded after reading before ordinary usage.</p><p>Data stored in the fields is deallocated automatically if not used any more
in any records.</p><p>Hence you should not use the decoded data in your own variables after storage,
unless you are sure the corresponding records are not deleted before you are
using your variables again.</p><p>The encoding principles are following, from smallest and fastest to
largest and slowest:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
0, small (28 bit) integers, fixpoint
  doubles, chars, dates and times
  are stored directly in the field, no additional
  allocation is done, no special deallocation is done.
</li><li class="listitem">
Records are encoded as an offset from the start of the shared memory segment
  to the start of the record. The encoded value is stored directly in a field.
  It can be decoded into a direct pointer to the start of the record data in
  the shared memory.
</li><li class="listitem">
large integers and doubles are allocated one copy per data item, in a 4
  byte or 8 byte chunk.
</li><li class="listitem">
Short simple strings up to 32 bytes are allocated one copy per data item,
  always 32 bytes.
</li><li class="listitem">
Long strings, strings with added language property, xmlliterals, uris, blobs
  are kept uniquely: only one copy of each item is allocated. They are deallocated
  automatically when the reference count falls to zero (reference counting
  garbage collection is used).
</li><li class="listitem"><p class="simpara">
Long strings, xmlliterals, uris and blobs have different types (not equal even
  if they look the same when printed) and they all contain two strings:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
main part (string, xmlliteral, uri, blob)
</li><li class="listitem">
extra part (string language, xmlliteral namespace, uri prefix, blob type)
    where all these are ordinary 0-terminated C strings except blob, which is not
    0-terminated.
  It is always possible to give a NULL value as an extra part.
</li></ul></div></li><li class="listitem">
Strings and blob returned by decoding strings, xmlliterals, uris and blobs
  should not be changed or used directly except for immediate copying to buffer.
  Prefer to use the decodeâ¦copy functions instead of direct decode functions
  giving a pointer to a string in the database.
</li><li class="listitem">
A WG_ILLEGAL value is returned in case of encoding error.
  A value returned in case of decoding error is sometimes not recognizable as
  an error. In string-type value decoding NULL is returned in case of
  decoding errors, length and date/time decoding errors return  -1.
</li></ul></div><p>Functions:</p><pre class="programlisting">wg_int wg_get_encoded_type(void* db, wg_int data);
wg_int wg_free_encoded(void* db, wg_int data);

wg_int wg_encode_null(void* db, wg_int data);
wg_int wg_decode_null(void* db, wg_int data);

wg_int wg_encode_int(void* db, wg_int data);
wg_int wg_decode_int(void* db, wg_int data);

wg_int wg_encode_char(void* db, char data);
char wg_decode_char(void* db, wg_int data);

wg_int wg_encode_record(void* db, void* data);
void* wg_decode_record(void* db, wg_int data);

wg_int wg_encode_double(void* db, double data);
double wg_decode_double(void* db, wg_int data);

wg_int wg_encode_fixpoint(void* db, double data);
double wg_decode_fixpoint(void* db, wg_int data);

wg_int wg_encode_date(void* db, int data);
int wg_decode_date(void* db, wg_int data);

wg_int wg_encode_time(void* db, int data);
int wg_decode_time(void* db, wg_int data);

int wg_current_utcdate(void* db);
int wg_current_localdate(void* db);
int wg_current_utctime(void* db);
int wg_current_localtime(void* db);

int wg_strf_iso_datetime(void* db, int date, int time, char* buf);
int wg_strp_iso_date(void* db, char* buf);
int wg_strp_iso_time(void* db, char* inbuf);

int wg_ymd_to_date(void* db, int yr, int mo, int day);
int wg_hms_to_time(void* db, int hr, int min, int sec, int prt);
void wg_date_to_ymd(void* db, int date, int *yr, int *mo, int *day);
void wg_time_to_hms(void* db, int time, int *hr, int *min, int *sec, int *prt);

wg_int wg_encode_str(void* db, char* str, char* lang);

char* wg_decode_str(void* db, wg_int data);
char* wg_decode_str_lang(void* db, wg_int data);

wg_int wg_decode_str_len(void* db, wg_int data);
wg_int wg_decode_str_lang_len(void* db, wg_int data);
wg_int wg_decode_str_copy(void* db, wg_int data, char* strbuf, wg_int buflen);
wg_int wg_decode_str_lang_copy(void* db, wg_int data, char* langbuf, wg_int buflen);

wg_int wg_encode_xmlliteral(void* db, char* str, char* xsdtype);
char* wg_decode_xmlliteral_copy(void* db, wg_int data);
char* wg_decode_xmlliteral_xsdtype_copy(void* db, wg_int data);

wg_int wg_decode_xmlliteral_len(void* db, wg_int data);
wg_int wg_decode_xmlliteral_xsdtype_len(void* db, wg_int data);
wg_int wg_decode_xmlliteral(void* db, wg_int data, char* strbuf, wg_int buflen);
wg_int wg_decode_xmlliteral_xsdtype(void* db, wg_int data, char* strbuf, wg_int buflen);

wg_int wg_encode_uri(void* db, char* str, char* nspace);
char* wg_decode_uri(void* db, wg_int data);
char* wg_decode_uri_prefix(void* db, wg_int data);

wg_int wg_decode_uri_len(void* db, wg_int data);
wg_int wg_decode_uri_prefix_len(void* db, wg_int data);
wg_int wg_decode_uri_copy(void* db, wg_int data, char* strbuf, wg_int buflen);
wg_int wg_decode_uri_prefix_copy(void* db, wg_int data, char* strbuf, wg_int buflen);

wg_int wg_encode_blob(void* db, char* str, char* type, wg_int len);
char* wg_decode_blob(void* db, wg_int data);
char* wg_decode_blob_type(void* db, wg_int data);
wg_int wg_decode_blob_len(void* db, wg_int data);
wg_int wg_decode_blob_copy(void* db, wg_int data, char* strbuf, wg_int buflen);
wg_int wg_decode_blob_type_len(void* db, wg_int data);
wg_int wg_decode_blob_type_copy(void* db, wg_int data, char* langbuf, wg_int buflen);

wg_int wg_encode_var(void* db, wg_int data);
wg_int wg_decode_var(void* db, wg_int data);</pre><p>Details:</p><pre class="literallayout">wg_int wg_get_encoded_type(void* db, wg_int data)</pre><p>Return a type of the encoded data (see the documentation for
<a class="xref" href="#anchor-2">wg_get_field_type()</a>)</p><pre class="literallayout">wg_int wg_free_encoded(void* db, wg_int data)</pre><p>Deallocate encoded data.</p><p>You need to deallocate data if and only if you have encoded it yourself
(not read from the field) and have not stored it into any fields.</p><p>In case the data is stored in a field, you should never deallocate it,
otherwise unexpected errors will occur.</p><p>In case a field is written over or a record is deleted, deallocation
is done automatically and properly.</p><pre class="literallayout">wg_int wg_encode_null(void* db, wg_int data)
wg_int wg_decode_null(void* db, wg_int data)</pre><p>Not strictly needed; encoded value 0 stands for NULL.</p><pre class="literallayout">wg_int wg_encode_int(void* db, wg_int data)
wg_int wg_decode_int(void* db, wg_int data)</pre><p>Encode/decode integers. Observe that shorter integers (28 bits) take
less space and are a bit faster: they are kept directly in the field.</p><pre class="literallayout">wg_int wg_encode_char(void* db, char data)
char wg_decode_char(void* db, wg_int data)</pre><p>Encode/decode a single char. Kept directly in the field.</p><pre class="literallayout">wg_int wg_encode_record(void* db, void* data)
void* wg_decode_record(void* db, wg_int data)</pre><p>Encodes/decode a pointer to the record.</p><pre class="literallayout">wg_int wg_encode_double(void* db, double data)
double wg_decode_double(void* db, wg_int data)</pre><p>Encode/decode ordinary doubles. Allocated separately.</p><pre class="literallayout">wg_int wg_encode_fixpoint(void* db, double data)
double wg_decode_fixpoint(void* db, wg_int data)</pre><p>Encode/decode doubles as small and fast fixpoint numbers.
Data must be a double between -800â¦800, four places after
comma are kept after rounding.</p><pre class="literallayout">wg_int wg_encode_date(void* db, int data)
int wg_decode_date(void* db, wg_int data)</pre><p>Unencoded date is a number of years since year 0.
Use 1 as the first year.</p><p>Kept directly in the field.</p><pre class="literallayout">wg_int wg_encode_time(void* db, int data)
int wg_decode_time(void* db, wg_int data)</pre><p>Unencoded time is a number of 100-ths of a seconds
past midnight.</p><p>Kept directly in the field.</p><pre class="literallayout">int wg_current_utcdate(void* db)
int wg_current_localdate(void* db)
int wg_current_utctime(void* db)
int wg_current_localtime(void* db)</pre><p>Gives current unencoded date or time, either utc or local.</p><pre class="literallayout">int wg_strf_iso_datetime(void* db, int date, int time, char* buf)</pre><p>Stores unencoded date and time as an iso datetime with 100-ths of seconds
in the buf using iso format like 2010-03-31T12:59:00.33</p><pre class="literallayout">int wg_strp_iso_date(void* db, char* buf)
int wg_strp_iso_time(void* db, char* inbuf)</pre><p>Parses unencoded date or time from the part of iso string like
2010-03-31 or 12:59:00.33 and returns it.</p><pre class="literallayout">int wg_ymd_to_date(void* db, int yr, int mo, int day)
int wg_hms_to_time(void* db, int hr, int min, int sec, int prt)</pre><p>Return scalar date or time like the above ISO string parsing
functions, except the parameters are given as integer
values (for ex: 2010, 1, 7).</p><pre class="literallayout">void wg_date_to_ymd(void* db, int date, int *yr, int *mo, int *day)
void wg_time_to_hms(void* db, int time, int *hr, int *min, int *sec, int *prt)</pre><p>Reverse conversion functions for scalar date and time into separate
integer values.</p><pre class="literallayout">wg_int wg_encode_str(void* db, char* str, char* lang)
char* wg_decode_str(void* db, wg_int data)
char* wg_decode_str_lang(void* db, wg_int data)
wg_int wg_decode_str_len(void* db, wg_int data)
wg_int wg_decode_str_lang_len(void* db, wg_int data)
wg_int wg_decode_str_copy(void* db, wg_int data, char* strbuf, wg_int buflen)
wg_int wg_decode_str_lang_copy(void* db, wg_int data, char* langbuf, wg_int buflen)</pre><p>All strings are 0-terminated standard C strings.</p><p>Lang parameter is the extra-string which may be given 0.
Simple decode returns a pointer to the string. <code class="literal">wg_decode_str_copy()</code> copies the
string to the given buffer with a given buflen.</p><p>A WG_ILLEGAL value is returned in case of encoding error, NULL in case
of string decoding errors, -1 in case of length decoding errors.</p><pre class="literallayout">wg_int wg_encode_xmlliteral(void* db, char* str, char* xsdtype)
char* wg_decode_xmlliteral_copy(void* db, wg_int data)
char* wg_decode_xmlliteral_xsdtype_copy(void* db, wg_int data)
wg_int wg_decode_xmlliteral_len(void* db, wg_int data)
wg_int wg_decode_xmlliteral_xsdtype_len(void* db, wg_int data)
wg_int wg_decode_xmlliteral(void* db, wg_int data, char* strbuf, wg_int buflen)
wg_int wg_decode_xmlliteral_xsdtype(void* db, wg_int data, char* strbuf, wg_int buflen)</pre><p>Analogous to str functions, the extra-string represents xmlliteral xsdtype,
may be NULL.</p><pre class="literallayout">wg_int wg_encode_uri(void* db, char* str, char* nspace)
char* wg_decode_uri(void* db, wg_int data)
char* wg_decode_uri_prefix(void* db, wg_int data)
wg_int wg_decode_uri_len(void* db, wg_int data)
wg_int wg_decode_uri_prefix_len(void* db, wg_int data)
wg_int wg_decode_uri_copy(void* db, wg_int data, char* strbuf, wg_int buflen)
wg_int wg_decode_uri_prefix_copy(void* db, wg_int data, char* strbuf, wg_int buflen)</pre><p>Analogous to str functions, the extra-string represents uri prefix,
may be NULL.</p><pre class="literallayout">wg_int wg_encode_blob(void* db, char* str, char* type, wg_int len)
char* wg_decode_blob(void* db, wg_int data)
char* wg_decode_blob_type(void* db, wg_int data)
wg_int wg_decode_blob_len(void* db, wg_int data)
wg_int wg_decode_blob_copy(void* db, wg_int data, char* strbuf, wg_int buflen)
wg_int wg_decode_blob_type_len(void* db, wg_int data)
wg_int wg_decode_blob_type_copy(void* db, wg_int data, char* langbuf, wg_int buflen)</pre><p>Analogous to str functions, except that:
- data is not 0-terminated, length must be always passed.
- the extra-string represents blob type, may be NULL</p><pre class="literallayout">wg_int wg_encode_var(void* db, wg_int data)
wg_int wg_decode_var(void* db, wg_int data)</pre><p>Data to be encoded is a variable identifier which is an integer. Values
up to 28 bit size may be safely used on any modern hardware.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_dumping_and_restoring_database_contents_to_from_disk"></a>4.7.Â Dumping and restoring database contents to/from disk</h3></div></div></div><p>Functions:</p><pre class="programlisting">wg_int wg_dump(void * db,char* fileName);
wg_int wg_import_dump(void * db,char* fileName);

wg_int wg_start_logging(void *db);
wg_int wg_stop_logging(void *db);
wg_int wg_replay_log(void *db, char *filename);</pre><p>Details:</p><pre class="literallayout">wg_int wg_dump(void * db,char* fileName)</pre><p>Dump shared memory database to the disk. If the database has journal logging
enabled, this will also restart the journal (creating a fresh journal file).
Returns 0 on success, -1 on non-fatal error and -2 on a fatal error. In case of
a fatal error, the database is in a corrupt state and should not (or cannot) be
used further.</p><pre class="literallayout">wg_int wg_import_dump(void * db,char* fileName)</pre><p>Import database from the disk. If the database has journal logging enabled,
this will also start the journal log (creating a fresh journal file) when the
import is completed. Note that whether the journal is enabled is determined by
the <span class="strong"><strong>current</strong></span> memory segment, not the state of the database at the moment the
dump was created.</p><p>Returns 0 on success, -1 on non-fatal error and -2 on a fatal error. In case
of a fatal error, the database is in a corrupt state. Otherwise, the
import failed (dump file not found or incompatible format), but the
memory image was not modified.</p><pre class="literallayout">wg_int wg_start_logging(void *db)</pre><p>Start the journal log. The journal logs are created in the directory
determined at compilation time and have a name following the pattern
<span class="emphasis"><em>wgdb.journal.&lt;shmname&gt;</em></span> where <span class="emphasis"><em>shmname</em></span> is the name of the database.
Call to this function always causes a new journal file to be created. When
a previous journal file exists at the time the journal is started, it is
backed up into a file named <span class="emphasis"><em>wgdb.journal.&lt;shmname&gt;.&lt;serial&gt;</em></span> where <span class="emphasis"><em>serial</em></span>
is the next available suffix. If there are too many backups already present,
the oldest one is overwritten instead.</p><p>Returns 0 on success, -1 when logging is already active, -2 when the function
failed and logging is not active and -3 when additionally, the log file was
possibly destroyed</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Normally, the journal is started upon the database creation by
calling <code class="literal">wg_attach_logged_database()</code> and it is not necessary to
call this function.</p></td></tr></table></div><pre class="literallayout">wg_int wg_stop_logging(void *db)</pre><p>Suspend the journal log. None of the writes by any client connected
to the database will be logged from this point. Returns 0 on success,
non-zero on failure.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Normally it is not necessary to manually stop and start the journal.</p></td></tr></table></div><pre class="literallayout">wg_int wg_replay_log(void *db, char *filename)</pre><p>Restore the database from the journal. If logging is enabled, this function
will also suspend the journal during the restore and restart it afterwards
(creating a fresh journal file). Returns 0 on success, -1 on non-fatal error
and -2 on a fatal error. In case of a fatal error, the database is in a corrupt
state.  Otherwise, the replay failed, but the database currently in memory was
not modified.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_journal_restarts_and_filenames"></a>Journal restarts and filenames</h4></div></div></div><p>The current journal file always has the name <span class="emphasis"><em>wgdb.journal.&lt;shmname&gt;</em></span> (for
example, <span class="emphasis"><em>wgdb.journal.1000</em></span>). If the database has logging enabled, all of the
writes will be recorded in that file.</p><p>Journal restarts will cause the current journal to be backed up and the
<span class="emphasis"><em>wgdb.journal.&lt;shmname&gt;</em></span> file will be replaced with a fresh journal.</p><p>Example 1:</p><p>Only <span class="emphasis"><em>wgdb.journal.99</em></span> exists. The database is dumped to the disk, causing
a journal restart. The filenames after the restart will be:</p><pre class="literallayout">wgdb.journal.99 --&gt; wgdb.journal.99.0
a new empty journal --&gt; wgdb.journal.99</pre><p>Example 2:</p><p>The current journal is <span class="emphasis"><em>wgdb.journal.1000</em></span>. There is also an older backup
with the name <span class="emphasis"><em>wgdb.journal.1000.0</em></span>. The new filenames:</p><pre class="literallayout">wgdb.journal.1000 --&gt; wgdb.journal.1000.1
wgdb.journal.1000.0 --&gt; wgdb.journal.1000.0 (unchanged)
a new empty journal --&gt; wgdb.journal.1000</pre><p>Example 3:</p><p>There are 10 backups (the maximum amount the database is configured to handle).
The oldest one of them is <span class="emphasis"><em>wgdb.journal.1000.0</em></span>, the newest one is
<span class="emphasis"><em>wgdb.journal.1000.9</em></span>. There is also the current journal <span class="emphasis"><em>wgdb.journal.1000</em></span>.
After the restart, the filenames are:</p><pre class="literallayout">wgdb.journal.1000 --&gt; wgdb.journal.1000.0 (overwriting the oldest backup)
wgdb.journal.1000.1 --&gt; wgdb.journal.1000.1 (unchanged)
...
wgdb.journal.1000.9 --&gt; wgdb.journal.1000.9 (unchanged)
a new empty journal --&gt; wgdb.journal.1000</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_interaction_between_dump_files_and_journal"></a>Interaction between dump files and journal</h4></div></div></div><p>If the database has journal logging enabled, the latest database
state is normally recoverable by importing the latest dump (if it
exists) and replaying the journal created after that dump (or at
the initialization of the database, if there is no dump).</p><p>When dumping the database, the journal will be restarted and will
be generated into a new file. Importing a dump will also have the
same effect.</p><p>Journal replay also causes the journal to be restarted so that
the point of restore is distinguishable later. However, in this
situation, the latest database state will be represented, incrementally,
by the latest dump, the recovered journal and the new journal (until
a new dump is created).</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_read_and_write_locking_the_database_for_concurrency_control"></a>4.8.Â Read and write locking the database for concurrency control</h3></div></div></div><p>Functions:</p><pre class="programlisting">wg_int wg_start_write(void * dbase);          /* start write transaction */
wg_int wg_end_write(void * dbase, wg_int lock); /* end write transaction */
wg_int wg_start_read(void * dbase);           /* start read transaction */
wg_int wg_end_read(void * dbase, wg_int lock);  /* end read transaction */</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_overview"></a>Overview</h4></div></div></div><p>Concurrency control in WhiteDB is achieved using a single
database-level shared/exclusive lock. It is implemented independently
of the rest of the db API (currently) - therefore use of the locking
routines does not automatically guarantee isolation.</p><p>Generally, a database level lock is characterized by very low overhead
but maximum possible contention. This means that processes should spend
as little time between acquiring a lock and releasing it, as possible.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_implementation_and_current_limitations"></a>Implementation and current limitations</h4></div></div></div><p>There are three alternative implementations.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Simple reader-preference lock using a single global spinlock
   (described by Mellor-Crummey &amp; Scott '92). Reader-preference
   means that this lock can cause writer starvation. Tests have
   shown good performance under N&gt;&gt;P conditions (N- number of
   processes, P- number of CPU-s).
</li><li class="listitem">
A writer-preference version of the spinlock.
</li><li class="listitem">
A task-fair lock implemented using a queue. This lock is not
   susceptible to starvation, but has higher overhead compared to
   the spinlocks. The waiting processes are synchronized using the
   futex kernel interface.
</li></ul></div><p>Current limitations:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
dead processes hold locks indefinitely.
</li><li class="listitem">
maximum timeout with spinlocks is 2000 ms.
</li><li class="listitem">
the task-fair lock is only supported on Linux.
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_configuration"></a>Configuration</h4></div></div></div><p>By default, WhiteDB is compiled with the task-fair lock if it is available
and reader-preference spinlock otherwise. The writer-preference lock is
selected by <code class="literal">./configure --enable-locking=wpspin</code>. The reader-preference lock
is selected by <code class="literal">./configure --enable-locking=rpspin</code>.</p><p>When using manual build, the LOCK_PROTO macro in <span class="emphasis"><em>config.h</em></span> (or <span class="emphasis"><em>config-w32.h</em></span>)
can be modified to select the locking method.</p><p>For plaforms that do not support the atomic operations, use
<code class="literal">./configure --disable-locking</code> or edit the appropriate header file and
comment out the LOCK_PROTO macro. This will allow the code to compile
correctly, but the database should be used by a single user or process only.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_usage"></a>Usage</h4></div></div></div><p>Getting a shared (read) lock:</p><pre class="programlisting">wg_int lock_id;
void *db; /* should be initialized before calling wg_start_read() */

...

/* acquire lock. This function normally blocks until the lock
 * is aquired
 */
lock_id = wg_start_read(db);
if(!lock_id) {
  /* getting the lock failed, do something */
} else {

  ... one or more database reads ...

  /* release the lock */
  if(!wg_end_read(db, lock_id)) {
    /* this is unlikely to fail, but if it does, the consequenses
     * could be severe, so this error should also be handled. */
  }
}</pre><p>Getting an exclusive (write) lock is similar:</p><pre class="programlisting">wg_int lock_id;

...

/* acquire lock. */
lock_id = wg_start_write(db);
if(!lock_id) {
  /* getting the lock failed, do something */
} else {

  ... one or more database write operations ...

  /* release the lock */
  if(!wg_end_write(db, lock_id)) {
    /* handle error */
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_porting"></a>Porting</h4></div></div></div><p>For platforms that do not support either GNU C or Win32 builtin functions
that implement the atomic operations in <span class="emphasis"><em>dblock.c</em></span>, appropriate code should
be added to each of the platform-specific helper functions.</p><p>The macro _MM_PAUSE can generally be defined as empty on platforms that
do not support Pentium 4/Athlon64-specific "pause" instruction. This will not
have a significant effect (or in other words, the "pause" instruction is
only actually useful on aforementioned processor families).</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_writing_safely_without_a_write_lock"></a>4.9.Â Writing safely without a write lock</h3></div></div></div><p>Although it is in general crucial to use wg_start_write before writing any data in a
concurrent setting, in simple special cases it is possible to safely avoid write locks
while writing data.</p><p>The following atomic functions all assume that the field contains an immediate value (NULL,
short integer, char, date or time), the value written is also immediate, the field is not
indexed and logging is not activated. This guarantees that no allocation operations are
performed and thus it is safe to rely on read locks (wg_start_read and wg_end_read)
while writing data:</p><pre class="programlisting">wg_int wg_update_atomic_field(void* db, void* record, wg_int fieldnr, wg_int data, wg_int old_data);
wg_int wg_set_atomic_field(void* db, void* record, wg_int fieldnr, wg_int data);
wg_int wg_add_int_atomic_field(void* db, void* record, wg_int fieldnr, int data);</pre><p>Details:</p><pre class="literallayout">wg_update_atomic_field(void* db, void* record, wg_int fieldnr, wg_int data, wg_int old_data);</pre><p>Given the assumptions described before, write data to field which is currently contains old_data.
If the field does not contain old_data while writing, an error is generated and writing is cancelled:
this is checked by the atomic compare-and-swap operation. Returns 0 if the operation was successful.</p><pre class="literallayout">wg_set_atomic_field(void* db, void* record, wg_int fieldnr, wg_int data);</pre><p>Perform the wg_update_atomic_field operation using the current value as old_data iteratively
until it succeeds. In a normal situation the operation is expected to succeed immediately
without any iterations. All the preconditions described before are checked.
Returns 0 if the operation was successful.</p><pre class="literallayout">wg_add_int_atomic_field(void* db, void* record, wg_int fieldnr, int data);</pre><p>Increase or decrease an existing short integer value in the field by adding integer data to this value.
Performs an atomic update operation iteratively until it succeeds. In a normal situation the operation
is expected to succeed immediately without any iterations.
All the preconditions described before are checked. Returns 0 if the operation was successful.</p><p>The three atomic functions may return any of these errors:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-1 if wrong db pointer
</li><li class="listitem">
-2 if wrong fieldnr
</li><li class="listitem">
-10 if new value non-immediate
</li><li class="listitem">
-11 if old value non-immediate
</li><li class="listitem">
-12 if cannot fetch old data
</li><li class="listitem">
-13 if the field has an index
</li><li class="listitem">
-14 if logging is active
</li><li class="listitem">
-15 if the field value has been changed from old_data
</li><li class="listitem">
-16 if the result of the addition does not fit into a smallint
</li><li class="listitem">
-17 if atomic assignment failed after a large number (1000) of tries
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_semi_structured_data"></a>4.10.Â Semi-structured data</h3></div></div></div><pre class="programlisting">wg_int wg_parse_json_file(void *db, char *filename);
wg_int wg_parse_json_document(void *db, char *buf, void **document);
wg_int wg_parse_json_fragment(void *db, char *buf, void **document);</pre><p>Details:</p><pre class="literallayout">wg_int wg_parse_json_file(void *db, char *filename)</pre><p>Parses JSON data from a file and insert it into the database as structured
records. The parsing is done in two passes - first a syntax checking pass and
then data insertion pass. If the JSON data is invalid, the database contents
are not modified.</p><p>Returns 0 if the data is stored successfully, -1 if there is a non-fatal (most
likely syntax) error and -2 if the storing fails and the database is
inconsistent after the function returns.</p><pre class="literallayout">wg_int wg_parse_json_document(void *db, char *buf, void **document)</pre><p>Parses JSON data from the buffer and inserts it into the database. There is
no separate syntax checking pass so the JSON input should be valid.</p><p>Returns 0 if the data is stored successfully, -1 if there is a non-fatal error
and -2 if the storing fails and the database is inconsistent after the function
returns. If the function is successful, <span class="emphasis"><em>**document</em></span> is set to point to the
top-level record in the structure. The resulting data is marked as a whole
document, meaning that it is can be treated as a single unit of data by
API functions that are JSON-aware.</p><pre class="literallayout">wg_int wg_parse_json_fragment(void *db, char *buf, void **document)</pre><p>Like <code class="literal">wg_parse_json_document()</code> except the resulting data is not marked as
a whole document.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_data_representation"></a>Data representation</h4></div></div></div><p>The JSON is converted to a semi-structured schema by creating a hierarchy of
records. The top-level record in this hierarchy is additionally marked as
a document, allowing to handle JSON documents as single units of data.</p><p>Conversion of JSON to whitedb semi-structured schema:</p><div class="informaltable"><table cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>JSON</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>whitedb</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>top-level</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>object or mapping</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>record containing references to key-value pairs</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>yes</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>-</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>record containing a single key-value pair</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>no</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>array</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>record (same length as array)</p></td><td style="" align="left" valign="top"><p>yes</p></td></tr></tbody></table></div><p>Array record fields and value fields may contain either immediate values
or recursively other arrays or objects. The object record fields always
contain links to key-value pair records. The key-value pair record holds
the key (a string) in column 1 and the value in column 2.</p><p>Example:</p><p>The JSON <span class="emphasis"><em>{"a" : [1, 2, 3], "b" : "c"}</em></span> would be converted to</p><pre class="literallayout">      [ record link | record link ]*
        /                   \
[  | "a" | record link ]  [  | "b" | "c" ]
              /
       [ 1 | 2 | 3 ]</pre><p>Where <span class="emphasis"><em>*</em></span> marks the top-level record in the document.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_utilities"></a>4.11.Â Utilities</h3></div></div></div><pre class="literallayout">void wg_print_db(void *db)</pre><p>Print entire database contents in stdout, row by row.</p><pre class="literallayout">void wg_print_record(void *db, wg_int* rec)</pre><p>Print just one row, pointed to by rec.</p><pre class="literallayout">void wg_snprint_value(void *db, wg_int enc, char *buf, int buflen)</pre><p>Print a single, encoded value into a character buffer.</p><pre class="literallayout">wg_int wg_parse_and_encode(void *db, char *buf)</pre><p>Parse value from a string, encode it for WhiteDB. Returns WG_ILLEGAL if value
could not be parsed or encoded. Following types are detected automatically
from the input:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
NULL - empty string
</li><li class="listitem">
int - plain integer
</li><li class="listitem">
double - floating point number in fixed decimal notation
</li><li class="listitem">
date - ISO8601 date
</li><li class="listitem">
time - ISO8601 time+fractions of second.
</li><li class="listitem">
string - input data that does not match the above types
</li></ul></div><p>Does NOT support ambiguous types:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
fixpoint - floating point number in fixed decimal notation
</li><li class="listitem">
uri - string starting with an URI prefix
</li><li class="listitem">
char - single character
</li></ul></div><p>Does NOT support types which would require a special encoding
scheme in string form:
record, XML literal, blob, anon const, variables</p><p>Note that double values need to have CSV_DECIMAL_SEPARATOR as the
decimal marker, independent of the system locale settings.</p><pre class="literallayout">wg_int wg_parse_and_encode_param(void *db, char *buf)</pre><p>Like <code class="literal">wg_parse_and_encode()</code>, except the returned value is encoded as a query
parameter. Values encoded like this should be freed with wg_free_query_param()
and cannot be used interchangeably with other encoded values.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="anchor-6"></a>4.12.Â Query functions</h3></div></div></div><pre class="programlisting">wg_query *wg_make_query(void *db, void *matchrec, wg_int reclen,
  wg_query_arg *arglist, wg_int argc);
void *wg_fetch(void *db, wg_query *query);
void wg_free_query(void *db, wg_query *query);

wg_int wg_encode_query_param_null(void *db, char *data);
wg_int wg_encode_query_param_record(void *db, void *data);
wg_int wg_encode_query_param_char(void *db, char data);
wg_int wg_encode_query_param_fixpoint(void *db, double data);
wg_int wg_encode_query_param_date(void *db, int data);
wg_int wg_encode_query_param_time(void *db, int data);
wg_int wg_encode_query_param_var(void *db, wg_int data);
wg_int wg_encode_query_param_int(void *db, wg_int data);
wg_int wg_encode_query_param_double(void *db, double data);
wg_int wg_encode_query_param_str(void *db, char *data, char *lang);
wg_int wg_encode_query_param_xmlliteral(void *db, char *data, char *xsdtype);
wg_int wg_encode_query_param_uri(void *db, char *data, char *prefix);
wg_int wg_free_query_param(void* db, wg_int data);</pre><pre class="literallayout">wg_query *wg_make_query(void *db, void *matchrec, wg_int reclen,
 wg_query_arg *arglist, wg_int argc)</pre><p>Build a query using parameters in match record and argument list formats. The
match record is an array of encoded values of wg_int type. This can either be
allocated by the caller, in which case the reclen should contain the size of
the array, or point to an existing database record, in which case reclen must
be zero.</p><p>The argument list format consists of an array of:</p><pre class="programlisting">typedef struct {
  gint column;      /** column (field) number this argument applies to */
  gint cond;        /** condition (equal, less than, etc) */
  gint value;       /** encoded value */
} wg_query_arg;</pre><p>Available conditions are:</p><pre class="literallayout">WG_COND_EQUAL       =
WG_COND_NOT_EQUAL   !=
WG_COND_LESSTHAN    &lt;
WG_COND_GREATER     &gt;
WG_COND_LTEQUAL     &lt;=
WG_COND_GTEQUAL     &gt;=</pre><p>argc is the size of the array (at least 1 is required if arglist parameter
is given). The function returns NULL if there is an error, otherwise a pointer
to a query object is returned. When the query is no longer used,
wg_free_query() should be called to release itâs memory.</p><p>If arglist and matchrec are NULL, the query has no parameters and will return
all the rows in the database.</p><pre class="literallayout">void *wg_fetch(void *db, wg_query *query)</pre><p>Fetch next row from the query result. Returns a pointer to the next
row (same as <code class="literal">wg_get_next_record()</code>). Returns NULL if there are no more rows.</p><pre class="literallayout">void wg_free_query(void *db, wg_query *query)</pre><p>Release the memory pointed to by query.</p><pre class="literallayout">wg_int wg_encode_query_param_*()</pre><p>Family of functions to prepare the parameters for <code class="literal">wg_make_query()</code>. They
return a WhiteDB encoded value when successful or WG_ILLEGAL on failure.
Locking the database when using these functions is not required,
since they do not access shared memory.</p><pre class="literallayout">wg_int wg_free_query_param(void* db, wg_int data)</pre><p>Free the storage allocated for the encoded data which has been prepared
with the <code class="literal">wg_encode_query_param_*()</code> family of functions. It is not advisable
to call this on data encoded with other functions.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_simplified_query_functions"></a>Simplified query functions</h4></div></div></div><pre class="programlisting">void *wg_find_record(void *db, wg_int fieldnr, wg_int cond, wg_int data,
    void* lastrecord);

void *wg_find_record_null(void *db, wg_int fieldnr, wg_int cond, char *data,
    void* lastrecord);
void *wg_find_record_record(void *db, wg_int fieldnr, wg_int cond, void *data,
    void* lastrecord);
void *wg_find_record_char(void *db, wg_int fieldnr, wg_int cond, char data,
    void* lastrecord);
void *wg_find_record_fixpoint(void *db, wg_int fieldnr, wg_int cond,
    double data, void* lastrecord);
void *wg_find_record_date(void *db, wg_int fieldnr, wg_int cond, int data,
    void* lastrecord);
void *wg_find_record_time(void *db, wg_int fieldnr, wg_int cond, int data,
    void* lastrecord);
void *wg_find_record_var(void *db, wg_int fieldnr, wg_int cond, wg_int data,
    void* lastrecord);
void *wg_find_record_int(void *db, wg_int fieldnr, wg_int cond, int data,
    void* lastrecord);
void *wg_find_record_double(void *db, wg_int fieldnr, wg_int cond, double data,
    void* lastrecord);
void *wg_find_record_str(void *db, wg_int fieldnr, wg_int cond, char *data,
    void* lastrecord);
void *wg_find_record_xmlliteral(void *db, wg_int fieldnr, wg_int cond,
    char *data, char *xsdtype, void* lastrecord);
void *wg_find_record_uri(void *db, wg_int fieldnr, wg_int cond, char *data,
    char *prefix, void* lastrecord);</pre><p>These functions provide a simplified alternative to the query functions.</p><pre class="literallayout">void *wg_find_record(void *db, wg_int fieldnr, wg_int cond, wg_int data,
  void* lastrecord);</pre><p>Returns the first record in the database that where "fieldnr" "cond" "data"
is true. <code class="literal">data</code> is an encoded value. <code class="literal">cond</code> is one of the conditions listed
under <a class="xref" href="#anchor-6" title="4.12.Â Query functions">SectionÂ 4.12, âQuery functionsâ</a>.</p><p>The <code class="literal">wg_find_record_*()</code> group of functions are convinience functions for
using unencoded data directly. The user is not required to encode or free
encoded data when using these functions.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_comparison_of_the_query_interfaces"></a>Comparison of the query interfaces</h4></div></div></div><div class="informaltable"><table cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Full query</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>simplified query</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>query type</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>conjunctive</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>one clause only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>without index</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>slower</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>faster</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>with index, fetch one row</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>slower</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>faster</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>with index, fetch many (&gt;5) rows</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>faster</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>much slower</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>isolation</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>"read commited"</p></td><td style="" align="left" valign="top"><p>none</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><span class="label label-info">!</span></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>the isolation level given here is only an approximation. Up to
"serializable" is currently possible with the use of <code class="literal">wg_start_*()</code>
and <code class="literal">wg_end_*()</code> functions, but this may become relaxed during future
development.</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_child_databases"></a>4.13.Â Child databases</h3></div></div></div><p>Note: child db is not compiled in by default. Use <code class="literal">./configure --enable-childdb</code>
or for manual build, edit the appropriate <span class="emphasis"><em>config-xxx.h</em></span> file and enable the
USE_CHILD_DB macro.</p><pre class="literallayout">wg_int wg_register_external_db(void *db, void *extdb)</pre><p>Store information in db about an external database extdb. This allows storing
data from extdb inside db. Returns 0 on success, negative on error.</p><pre class="literallayout">wg_int wg_encode_external_data(void *db, void *extdb, wg_int encoded)</pre><p>Translate an encoded value from extdb to another encoded value which may
be stored into db. Physically the data (assuming there is any memory
allocated) continues to reside in extdb.</p><p>Child databases are databases which contain references to data (fields and
records) located in another database, called parent. The requirement is
that both the child and parent are located in the same virtual address
space. A typical scenario is that a "main" shared memory database is used
as the parent and temporary, local memory databases are created as children.</p><p>Main difference between referring to local and external data is that
external references are (intentionally) not tracked by the parent database.
This allows instantly deleting the child databases. On the other hand,
extra measures must be taken to ensure that the referenced external data
stays intact while in use by the child database. Read locking the parent
database should be sufficient there.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_typical_usage_scenario"></a>Typical usage scenario</h4></div></div></div><p>(assuming parent is already created) Create a child database and
assign the parent.</p><pre class="programlisting">  childdb = wg_attach_local_database(size);
  wg_register_external_db(childdb, parentdb);</pre><p>Use parent data in child database. Encoded data from parent
database must be re-encoded before writing it to the child database.</p><pre class="programlisting">  tmp = wg_encode_external_data(childdb, parentdb, parentdata);
  wg_set_field(childdb, childrec, 0, tmp);</pre><p>Free child database, when done.</p><pre class="programlisting">wg_delete_local_database(childdb);</pre><p>There are three main restrictions when using external references:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
External references may not be written into shared memory databases. For this
  reason, <code class="literal">wg_register_external_db()</code> may only be called with a local (non-shared)
  database as the first argument.
</li><li class="listitem">
once an external database X is registered inside another database Y, the
  database Y may no longer be dumped/restored.
</li><li class="listitem">
A database that contains external references cannot be indexed.
</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_getting_information_about_the_database_state"></a>4.14.Â Getting information about the database state</h3></div></div></div><pre class="programlisting">wg_int wg_database_freesize(void *db);
wg_int wg_database_size(void *db);</pre><p>These functions provide information about the database size and available
free space.</p><pre class="literallayout">wg_int wg_database_size(void *db)</pre><p>Returns the total memory segment size for the database, in bytes.</p><pre class="literallayout">wg_int wg_database_freesize(void *db)</pre><p>Returns the amount of free space in the database memory segment, in bytes.
Note that this is a conservative estimate, meaning that the actual amount
of free space may be more, but no less, than reported.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_rdf_parsing_exporting_api"></a>5.Â RDF parsing / exporting API</h2></div></div></div><p>This API is dependent on libraptor. It is not available on Win32. When
compiling WhiteDB without autotools (using <code class="literal">compile.sh</code>) the API can be
enabled by defining HAVE_RAPTOR in <span class="emphasis"><em>config.h</em></span> and modifying build scripts
to link with appropriate libraries.</p><pre class="programlisting">#include "rdfapi.h"

wg_int wg_import_raptor_file(void *db, wg_int pref_fields, wg_int suff_fields,
  wg_int (*callback) (void *, void *), char *filename);
wg_int wg_import_raptor_rdfxml_file(void *db, wg_int pref_fields,
  wg_int suff_fields, wg_int (*callback) (void *, void *), char *filename);
wg_int wg_rdfparse_default_callback(void *db, void *rec);
wg_int wg_export_raptor_file(void *db, wg_int pref_fields, char *filename,
  char *serializer);
wg_int wg_export_raptor_rdfxml_file(void *db, wg_int pref_fields,
  char *filename);</pre><pre class="literallayout">wg_int wg_import_raptor_file(void *db, wg_int pref_fields, wg_int suff_fields,
 wg_int (*callback) (void *, void *), char *filename)</pre><p>Imports RDF file. Creates records with length = pref_fields + 3 + suff_fields.
The data will be stored as follows:</p><p>| pref_fields .. | predicate | subject | object | suff_fields |</p><p>The file type is determined automatically from filename. Callback function
should match the prototype of <code class="literal">wg_rdfparse_default_callback()</code> and can be used
to calculate contents of fields other than the RDF triple.</p><pre class="literallayout">wg_int wg_import_raptor_rdfxml_file(void *db, wg_int pref_fields,
 wg_int suff_fields, wg_int (*callback) (void *, void *), char *filename)</pre><p>As above, but file type is assumed to be RDF/XML</p><pre class="literallayout">wg_int wg_rdfparse_default_callback(void *db, void *rec)</pre><p>Does nothing. Called when importing rdf files with the <span class="emphasis"><em>wgdb</em></span> commandline tool.
May be modified to add field initialization functionality to commandline
importing.</p><pre class="literallayout">wg_int wg_export_raptor_file(void *db, wg_int pref_fields, char *filename,
 char *serializer)</pre><p>Export triple data to file. The format is selected by the raptor serializer
(more info about serializers can be found at <a class="ulink" href="http://librdf.org/raptor/" target="_top">http://librdf.org/raptor/</a>.
There is also serializers enumeration function in libraptor API). The
pref_fields parameters marks the start position of the triple in
WhiteDB records (storage schema is assumed to be the same as described
above for wg_import_raptor_file() function).</p><pre class="literallayout">wg_int wg_export_raptor_rdfxml_file(void *db, wg_int pref_fields,
 char *filename)</pre><p>Export triple data to file in RDF/XML format.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_index_api"></a>6.Â Index API</h2></div></div></div><pre class="programlisting">#include &lt;whitedb/indexapi.h&gt;

wg_int wg_create_index(void *db, wg_int column, wg_int type,
  wg_int *matchrec, wg_int reclen);
wg_int wg_drop_index(void *db, wg_int index_id);
wg_int wg_column_to_index_id(void *db, wg_int column, wg_int type,
  wg_int *matchrec, wg_int reclen);
wg_int wg_get_index_type(void *db, wg_int index_id);
void * wg_get_index_template(void *db, wg_int index_id, wg_int *reclen);
void * wg_get_all_indexes(void *db, wg_int *count);</pre><p>Index API header exposes functions to create and drop indexes.</p><pre class="literallayout">wg_int wg_create_index(void *db, wg_int column, wg_int type,
 wg_int *matchrec, wg_int reclen)</pre><p>Create an index on column. Index type must be specified. Currently
supported index types:</p><pre class="literallayout">WG_INDEX_TYPE_TTREE - T-tree index on single column</pre><p>If matchrec is NULL, a normal index is created. If matchrec is non-null,
the index will be created with a template. In this case reclen must specify
the length of the array pointed to by matchrec. If an index has a template,
only records that match the template are inserted into the index. Wildcards
in the template are specified using WG_VARTYPE values.</p><p>This function returns 0 if successful and non-0 in case of an error.</p><pre class="literallayout">wg_int wg_drop_index(void *db, wg_int index_id)</pre><p>Delete the specified index.</p><p>Returns 0 on success, non-0 on error.</p><pre class="literallayout">wg_int wg_column_to_index_id(void *db, wg_int column, wg_int type,
 wg_int *matchrec, wg_int reclen)</pre><p>Find an index on a column. If type is specified, the first index with
a matching type is returned. If type is 0, indexes of any type may be
returned.</p><p>If matchrec is non-NULL and WhiteDB is configured with USE_INDEX_TEMPLATE
option, the provided match record will be used to locate an index with
a specified template. If matchrec is NULL, this function finds a full
index.</p><p>Returns an index id on success. Returns -1 on error.</p><pre class="literallayout">wg_int wg_get_index_type(void *db, wg_int index_id)</pre><p>Finds index type.</p><p>Returns type (&gt;0) on success, -1 if the index was not found.</p><pre class="literallayout">void * wg_get_index_template(void *db, wg_int index_id, wg_int *reclen)</pre><p>Finds index template.</p><p>Returns a pointer to the gint array used for the index template. reclen is set
to the length of the array. The pointer may not be freed and itâs contents
should be accessed read-only.</p><p>If the index is not found or has no template, NULL is returned. In that case
contents of *reclen are unmodified.</p><pre class="literallayout">void * wg_get_all_indexes(void *db, wg_int *count)</pre><p>Returns a pointer to a NEW allocated array of index id-s. count is initialized
to the number of indexes in the array.</p><p>Returns NULL if there are no indexes.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_examples"></a>6.1.Â Examples</h3></div></div></div><p>Create a T-tree index on a column conditionally:</p><pre class="programlisting">  if(wg_column_to_index_id(db, col, WG_INDEX_TYPE_TTREE, NULL, 0) == -1) {
    if(wg_create_index(db, col, WG_INDEX_TYPE_TTREE, NULL, 0)) {
      printf("index creation failed.\n");
    } else {
      printf("index created.\n");
    }
  }</pre><p>Create an index on column 0 that only contains rows where the 2-nd column
is equal to 6 (requires that WhiteDB is compiled with USE_INDEX_TEMPLATE
defined in config.h):</p><pre class="programlisting">  wg_int matchrec[3];
  matchrec[0] = wg_encode_var(db, 0);
  matchrec[1] = wg_encode_var(db, 0);
  matchrec[2] = wg_encode_int(db, 6);
  if(wg_create_index(db, 0, WG_INDEX_TYPE_TTREE, matchrec, 3)) {
    printf("index creation failed.\n");
  }</pre><p>Delete all indexes in the database that have a template:</p><pre class="programlisting">  wg_int *indexes = wg_get_all_indexes(db, &amp;count);
  for(i=0; i&lt;count; i++) {
    wg_int index_id = indexes[i];
    int len;
    void *tmpl = wg_get_index_template(db, index_id, &amp;len);
    if(!tmpl) {
      printf("%d had no template\n", index_id);
    } else {
      wg_drop_index(db, index_id);
      printf("dropped %d\n", index_id);
    }
  }
  free(indexes);</pre></div></div></div>
      </div>
    </div>        
  </div>
</div> 

<!-- footer -->

<div class="ofooter">  
 <div class="col-md-12 container ifooter">
  <div id="team">
    <a href="contact.html" style="color: #666666; font-family: 'Roboto'; font-size: 16px;">WhiteDB team 2013</a>
  </div>    
  <p> 
  <div id="gplusone">
    <div class="g-plusone" data-annotation="none" data-size="large" data-expandTo="right"
        data-href="http://www.whitedb.org">
    </div>
  </div>
  <p>
  <div id="twitter">
    <div>
    <a href="https://twitter.com/share" class="twitter-share-button" 
         data-url="http://www.whitedb.org" data-hashtags="whitedb"
         data-text="a fast database library in shared memory">Tweet</a>
    </div>
  </div>
  <div id="facebook">
    <div class="fb-like" data-href="http://www.whitedb.org" 
        data-colorscheme="light" 
        data-layout="box-count" data-action="like" 
        data-show-faces="true" data-send="true">
    </div>
  </div>
  
  </div>  
</div> 

<!-- at-end-scripts -->

<!-- Bootstrap core JavaScript -->

<script src="js/bootstrap.min.js"></script>

<!-- social scripts -->

<script>
// facebook

(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=168856549986981";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));

// google+ 

(function() {
   var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
   po.src = 'https://apis.google.com/js/client:plusone.js?onload=gplus_render';
   //po.src = 'https://apis.google.com/js/plusone.js?';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
 })();

// twitter 

!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';
  if(!d.getElementById(id)){js=d.createElement(s);js.id=id;
  js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);
  }}(document, 'script', 'twitter-wjs');
    
// google analytics

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44786402-1', 'whitedb.org');
  ga('send', 'pageview');

</script>  
  
</body>
</html>
