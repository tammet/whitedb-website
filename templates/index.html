

<!-- Main jumbotron for a primary message -->
<div class="jumbotron">
  <div class="container">
    <h1 style="color: #bbbbbb; text-shadow: 2px 2px #f0f0f0;">Pure speed</h1>
    <p style="color: #666666; margin-bottom: 20px;">
    WhiteDB is a lightweight NoSQL database library written in C, operating fully in main memory. 
    There is no server process. Data is read and written directly from/to shared memory, no sockets are used between
    WhiteDB and the application program.</p>
    <p><a class="btn btn-primary btn-lg btn-top" style="margin-right: 30px;" href="tutorial.html">Tutorial </a>
       <a class="btn btn-default btn-lg btn-top" style="color: #bbbbbb; margin-right: 30px;" href="speed.html">Speed </a>
       <a class="btn btn-default btn-lg btn-top" style="color: #bbbbbb; margin-right: 30px;" href="download.html">Download </a></p>
  </div>
</div>

<div class="container">
  <!-- Example row of columns -->
  <div class="row">
    <div class="col-md-4 wblock wblock1">
      <div class="wiblock wiblock1">
      <h2>Project goals</h2>
      <ul>   
        <li>speed
        <li>portability
        <li>simplicity and small footprint 
        <li>low memory usage
        <li>easy to use in embedded systems 
        <li>graph database applications
        <li>extended rdf database applications       
        <li>fast interprocess communication
        <li>seamless integration with a wGandalf rule engine (work in progress)
      </ul> 
      </div>
    </div>
    <div class="col-md-4 wblock wblock1">
      <div class="wiblock wiblock2">
        <h2>Data storage</h2>
        <p>
        Data is kept in shared memory by default, making all the data accessible to separate processes.
        <p>
        Each database record is a tuple of N elements, encoded in WhiteDB-s simple compact format.
        You can store both conventional datatypes and direct pointers to records: the latter
        enables highly efficient traversal of complex data.
        <!--
        The available data types include decimal and floating point numbers, strings, URIs, time and date, BLOB,
        pointers to records and more. 
        -->
      </div>
    </div>
    <div class="col-md-4 wblock wblock1">
      <div class="wiblock wiblock3">
        <h2>Supported features</h2>
        <p>
        <ul>  
        <li>indexes (T-tree)
        <li>persistence through logging and memory dumps
        <li>concurrency through locking
        <li>limited queries (conjunctive only)
        <li>json, CSV and RDF support
        <li>Linux and Windows
        <li>Python bindings
        <li>command line utility tools
        <li>json REST tools
        </ul>
      </div>
   </div>
   
  </div>
</div>

<div class="container" style="margin-top: 25px; margin-bottom: 25px;">
<h1 style="text-align: center">Built with WhiteDB</h1>
</div>
  
<div class="container">
  <!-- Example row of columns -->
  <div class="row">
    <div class="col-md-4 wblock wblock2">
      <div class="wiblock wiblock1">
      <h2>Roboswarm</h2>   
        <div class="wiblockimg"><img  src="img/robotarmy_white_2.jpg"></img></div>
        <p> 
        An early version of WhiteDB was used in the Roboswarm EU project
        enhancing the (cooperative) intelligence of iRobot Roombas functioning
        as a swarm. 
        <p>
        All the external commands and data arriving from the robot sensors are stored in a WhiteDB
        onboard Roomba, running on a <a href="https://www.gumstix.com/">tiny linux computer</a>. The reasoner generates new
        tasks for the Roomba reactively, in real-time, using rules and the 
        WhiteDB contents.
        <p class="wiblockbtn" style="vertical-align: bottom">
          <a class="btn btn-primary" href="http://vimeo.com/user2952867/videos">Roboswarm videoclips &raquo;</a></p>  
      </div>
    </div>
    <div class="col-md-4 wblock wblock2">
      <div class="wiblock wiblock2">
      <h2>Travel planner</h2>
     <div class="wiblockimg"><img  src="img/planner.jpg"></img></div>   
        <p>
         The personalized tourism travel planner of a main national <a href="http://www.visitestonia.com">tourism site</a>
         uses WhiteDB as the storage for the hard search tasks.
         <p>
         The planner has to sift through, match and evaluate all the tourism objects in the country during
         a heuristics-guided search for the best available plan to visit interesting sites. 
         <p>
         <p class="wiblockbtn">
            <a class="btn btn-primary" href="http://www.visitestonia.com/en/travel-planner">Travel planner &raquo;</a></p>         
      </div>
    </div>
    <div class="col-md-4 wblock wblock2">
      <div class="wiblock wiblock3">
      <h2>Telemedicine</h2>
      <div class="wiblockimg"><img  src="img/Digibox.jpg"></img></div>    
       <p>
       Intelligent telemedicine systems developed at <a href="http://www.eliko.ee">eliko</a> use WhiteDB running on
       a small MIPS type CPU for storing and analysing sensor data.
       <p>
       The principles of using whiteboard systems with WhiteDB as a core tool for fast interprocess communication of multi-agent
       systems are described 
       in a Ph.D thesis "Whiteboard Architecture for the Multi-agent Sensor Systems" 
       <p class="wiblockbtn"><a class="btn btn-primary" href="doc/Reilent_phd_thesis.pdf">Thesis pdf &raquo;</a></p>
      </div>
   </div>
   
  </div>
</div>  

<div class="container" style="margin-top: 25px; margin-bottom: 25px;">
<h1 style="text-align: center">Technology</h1>
</div>
  
<div class="container">
  <!-- Example row of columns -->
  <div class="row">
    <div class="col-md-4 wblock wblock3">
      <div class="wiblock wiblock1">
      <h2>Direct memory access</h2>
      <p>
    Each record is stored as an array (N-tuple) of integers: configurable as either 32 or 64 bits. 
    The integers in the tuple encode values directly or as pointers. Columns have no type: any encoded
    value can be stored to any field.
    <p>
    You can always get a direct pointer to a record, store it into a field of a record 
    or use it in your own program directly. A record pointer can thus be used as an automatically
    assigned id of the record which requires no search at all to access the record.
    <p>
    To search for a record, either scan the chain of all records, scan a sublist/tree you
    have built yourself or perform an index search on an indexed field.
      </div>
    </div>
    <div class="col-md-4 wblock wblock3">
      <div class="wiblock wiblock2">
      <h2>Data encoding</h2>      
      <p>
      The low bits of an integer in a record indicate the type of data. Anything which does not fit into the
      remainining bits is allocated separately and pointed to by the same integer. 
      <p>
      The datatypes are null, record(pointer), integer, double, string, 
      xml literal, uri, blob,  char, date, time, pointer to record. 
      <p>
      Long strings are allocated uniquely, i.e. using the same string in many fields does not
      take up additional space and allows fast string equality check.    
      <p>      
      A record pointer is a persistent offset of the record, usable
      as an automatic id of the record. Pointers allow 
      <a href="http://en.wikipedia.org/wiki/Graph_database">fast traversal of
      complex data</a> without search.
      </div>
    </div>
    <div class="col-md-4 wblock wblock3">
      <div class="wiblock wiblock3">
      <h2>Allocation and garbage collection</h2>
      <p>
      Conventional 
      <a href="http://en.wikipedia.org/wiki/C_dynamic_memory_allocation">malloc</a> 
      does not function in shared memory, since we have to use offsets instead
      of conventional pointers. Hence WhiteDB uses its own implementation of malloc for 
      <a href="http://en.wikipedia.org/wiki/Shared_memory">shared memory</a>.
      <p>
      A record and a uniquely kept long string can be pointed to 
      from several fields.
      Hence we use 
      <a href="http://en.wikipedia.org/wiki/Reference_counting">reference counting garbage collection</a>
      embedded into
      our allocation algorithm when deleting records and long strings. 
      Reference counting is incremental and does not cause long
      pauses.      
      </div>
   </div>
   
  </div>
</div>  

<div class="container" style="margin-top: 10px;">
</div>

<div class="container">
  <!-- Example row of columns -->
  <div class="row">
    <div class="col-md-4 wblock wblock3">
      <div class="wiblock wiblock1">
      <h2>Locking</h2>
      <p>
  We use a database level lock implemented via a task-fair 
  atomic <a href="http://en.wikipedia.org/wiki/Spinlock">spinlock</a> queue for concurrency control,
  but alternative faster and simpler preference policies can be configured: either a  
  reader-preference or a writer-preference spinlock.
  <p>  
  Generally, a database level lock is characterized by very low overhead but 
  maximum possible contention. 
  This means that processes should spend as little time between 
  acquiring a lock and releasing it, as possible.
  <p>
  We provide safe atomic updates of simple values without taking a write lock.
      </div>
    </div>
    <div class="col-md-4 wblock wblock3">
      <div class="wiblock wiblock2">
      <h2>Indexes</h2>
      <p>
      The simplest index provided is a <a href="http://en.wikipedia.org/wiki/T-tree">T-tree index</a> on any field containing
      any mixture of objects (integers, strings, etc). The index is automatically maintained when records
      are added, deleted or changed.
      <p>
      The efficiency of indexing can be greatly enhanced by using template indexes, which
      create an index only for records having a given value in a given field. For example,         
      create an index on column 0 that only contains records where the 2-nd column is equal to 6.
      <p>
      Unique storage of long strings, xml literals and uri-s uses hash indexes internally.
      </div>
    </div>
    <div class="col-md-4 wblock wblock3">
      <div class="wiblock wiblock3">
      <h2>Persistent storage</h2>
      <p>
     Two mechanisms are available for storing the shared memory database to disk. First, the whole
    database can be dumped and restored. Since the database uses offsets instead of conventional
    pointers, the absolute adress locations are not important.
    <p>
    Second, all inserts, deletions and updates can be logged to a file. The compact log thus created can be played 
    back to restore the contents of the database (normally after the last dump). Logging can be switched
    on and off, depending on the data criticality/performance requirements.    
      </div>
   </div>
   
  </div>
</div>  

