<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>WhiteDB Tutorial</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="idm140311682349280"></a>WhiteDB Tutorial</h2></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#_introduction">1. Introduction</a></span></dt><dt><span class="section"><a href="#_compiling_the_examples">2. Compiling the examples</a></span></dt><dd><dl><dt><span class="section"><a href="#_so_you_8217_re_on_windows">2.1. So you’re on Windows</a></span></dt></dl></dd><dt><span class="section"><a href="#anchor-1">3. Connecting to the database</a></span></dt><dt><span class="section"><a href="#_adding_data_to_the_database">4. Adding data to the database</a></span></dt><dd><dl><dt><span class="section"><a href="#_records">4.1. Records</a></span></dt><dt><span class="section"><a href="#_data_in_whitedb">4.2. Data in WhiteDB</a></span></dt><dt><span class="section"><a href="#_setting_field_values">4.3. Setting field values</a></span></dt></dl></dd><dt><span class="section"><a href="#_the_wgdb_utility">5. The wgdb utility</a></span></dt><dd><dl><dt><span class="section"><a href="#_database_persistence_on_windows">5.1. Database persistence on Windows</a></span></dt><dt><span class="section"><a href="#anchor-2">5.2. Looking at data</a></span></dt><dt><span class="section"><a href="#_modifying_data">5.3. Modifying data</a></span></dt><dt><span class="section"><a href="#_freeing_the_memory">5.4. Freeing the memory</a></span></dt></dl></dd><dt><span class="section"><a href="#_making_queries">6. Making queries</a></span></dt><dd><dl><dt><span class="section"><a href="#_finding_matching_records">6.1. Finding matching records</a></span></dt><dt><span class="section"><a href="#_full_query_interface">6.2. Full query interface</a></span></dt></dl></dd><dt><span class="section"><a href="#_doing_things_properly">7. Doing things properly</a></span></dt><dt><span class="section"><a href="#_parallel_use">8. Parallel use</a></span></dt><dt><span class="section"><a href="#_network_database">9. Network database</a></span></dt><dd><dl><dt><span class="section"><a href="#_record_linking_in_whitedb">9.1. Record linking in WhiteDB</a></span></dt><dt><span class="section"><a href="#_when_to_use_the_network_model">9.2. When to use the network model</a></span></dt></dl></dd><dt><span class="section"><a href="#_more_examples">10. More examples</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction"></a>1. Introduction</h2></div></div></div><p>This tutorial will cover the basic usage of WhiteDB’s C API. Most examples
you will encounter here will also be available in the Examples directory
of the WhiteDB source distribution.</p><p>A thorough reference of the API is available in the <a class="ulink" href="Manual.html" target="_top">Manual</a>. If
you’re looking for information on how to use WhiteDB from Python, please see
<a class="ulink" href="python.html" target="_top">Python documentation</a> (also in semi-tutorial form).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_compiling_the_examples"></a>2. Compiling the examples</h2></div></div></div><p>Before we can get started with the tutorial, we need to know how to compile
and run programs that use WhiteDB.</p><p>If you invoked the standard <code class="literal">./configure; make; make install</code>, things are
quite simple. Let’s try to compile <span class="emphasis"><em>Examples/demo.c</em></span> (it’s already compiled,
but let’s do it again).</p><pre class="literallayout">gcc -o Examples/mydemo Examples/demo.c -lwgdb</pre><p>That’s it! This is how you’d normally compile and link a WhiteDB program.
The <code class="literal">-lwgdb</code> tells the linker to use <span class="emphasis"><em>libwgdb.a</em></span> that sits somewhere in your
library path. If you get an error at this point, it may be that your
computer has libraptor installed. In that case WhiteDB automatically decides
that it wants to use it; just add <code class="literal">-lraptor</code> to the command line and all
should be fine.</p><p>You can now run <code class="literal">Examples/mydemo</code> and see what it does. Also, you may skip the
rest of this section and go directly to <a class="xref" href="#anchor-1" title="3. Connecting to the database">Section 3, “Connecting to the database”</a>.</p><p>In the event that you haven’t run <code class="literal">make install</code> (let’s say you’re still
evaluating and getting acquainted with WhiteDB) or you’ve installed it
in a location that’s not in your standard library path, you’ll need to
add a few things.</p><pre class="literallayout">gcc -L/alternate/libpath -o Examples/mydemo Examples/demo.c -lwgdb</pre><p>Alternate libpath is where <span class="emphasis"><em>libwgdb.a</em></span> is on your machine. If you didn’t
<code class="literal">make install</code> at all, it is still in <span class="emphasis"><em>Main/.libs</em></span>. Also, your system probably
does not know where to look for the libraries, so if you just run
<code class="literal">Examples/mydemo</code>, it will exit with "error while loading shared libraries".</p><pre class="literallayout">LD_LIBRARY_PATH=/alternate/libpath Examples/mydemo</pre><p>will take care of that. However, things will definitely be easier once you’ve
done <code class="literal">make install</code>. Another issue that you might run into is that the compiler
does not know where the API header files are. The programs in the <span class="emphasis"><em>Examples</em></span>
directory work around that by referring to the headers in the <span class="emphasis"><em>Db</em></span> directory
directly, but you might prefer a more flexible way. In this case, try</p><pre class="literallayout">gcc -L/alternate/libpath -I/path/to/headers -o myprog myprog.c -lwgdb</pre><p>where <span class="emphasis"><em>/path/to/headers</em></span> is where <span class="emphasis"><em>dbapi.h</em></span> is located.</p><p>Finally, in the event that your system does not have the make
program or some other part of the toolchain required for the standard
installation, but you still have the C compiler, such as gcc, you may
directly compile the examples or your own programs with the WhiteDB sources.
Have a look at <span class="emphasis"><em>Examples/compile_demo.sh</em></span> to see what source files should
be compiled.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_so_you_8217_re_on_windows"></a>2.1. So you’re on Windows</h3></div></div></div><p>So far the there hasn’t been a peep about following the tutorial on a Windows
computer, but don’t feel left out - the compilation is different enough that
it deserves it’s own section.</p><p>You need the MSVC compiler (provided by Microsoft Visual Studio, Express
Edition, for example). Set it up so you can run <code class="literal">cl.exe</code> from the command
prompt. Visual Studio includes it’s own command prompt menu entry that has
the environment set up correctly for you.</p><p>First, we recommend that you compile the <span class="emphasis"><em>wgdb.lib</em></span>. If you followed the
installation documentation, you probably have it in WhiteDB’s directory
already. If not, run <code class="literal">compile.bat</code>. This produces everything you’ll
need for the tutorial. Now try:</p><pre class="literallayout">cl.exe /FeMYDEMO Examples\demo.c wgdb.lib</pre><p>This produces <span class="emphasis"><em>mydemo.exe</em></span> in the current directory. As long as the file
<span class="emphasis"><em>wgdb.dll</em></span> is also in the same directory, you can run <code class="literal">mydemo.exe</code> and see
the output.</p><p>The above command works for the distributed examples, but it should be
pointed out that the following way is more flexible, once you’ve started
creating your own programs:</p><pre class="literallayout">cl.exe /I"\path\to\whitedb\headers" yourprog.c \path\to\wgdb.lib</pre><p>Replace the <span class="emphasis"><em>\path\to..</em></span>-s with the actual directories where the WhiteDB files
are on your computer.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="anchor-1"></a>3. Connecting to the database</h2></div></div></div><p>Before you can read from or write to the WhiteDB database, your program
needs to connect to it. Let’s look at how we might do that (<span class="emphasis"><em>Examples/tut1.c</em></span>):</p><pre class="programlisting">#include &lt;whitedb/dbapi.h&gt; /* or #include &lt;dbapi.h&gt; on Windows */

int main(int argc, char **argv) {
  void *db;
  db = wg_attach_database("1000", 2000000);
  return 0;
}</pre><p>First, the program needs to include the API headers. There are a few other
header files distributed with WhiteDB, but <span class="emphasis"><em>dbapi.h</em></span> is the one we’ll need
for now.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The programs in the <span class="emphasis"><em>Examples</em></span> directory use a different way of including
the headers, by referring to their location directly. This is so that the
examples can be compiled before the installation of the database and it is
perfectly acceptable - but let’s stick to the standard way of using library
headers in this tutorial.</p></td></tr></table></div><p><code class="literal">void *db</code> is the database handle. Once we have the handle, we can use it in
all the subsequent database operations - it will always point to the same
database we originally attached to. Why stress that it is the same database?
WhiteDB allows using multiple databases in parallel, without any prior
configuration. The number "1000" we give to the <code class="literal">wg_attach_database()</code> function
is the key that refers to the shared memory segment containing our database.</p><p>Observe that when using <code class="literal">wg_attach_database()</code>, it does not matter whether the
database already exists or not - it will be created, if necessary. The size
of the database will be the one we supplied, 2MB in this case. When the
program exits, the database will remain in memory.</p><p>When you have already created a database in shared memory, you can later use
<code class="literal">wg_attach_existing_database(dbname)</code> which functions exactly as
<code class="literal">wg_attach_database(dbname,...)</code> but does not create a new database.
If no database with the name <code class="literal">dbname</code> is found, it simply returns NULL.
This is quite handy when you want to avoid creating a new base or just want
to check whether it exists already.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_adding_data_to_the_database"></a>4. Adding data to the database</h2></div></div></div><p>An empty database isn’t usually much of a practical use, so we need to learn
how to populate it with data. It is actually a three-step process: creating
a record, encoding the data and writing to the fields of the records.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_records"></a>4.1. Records</h3></div></div></div><p>A WhiteDB record is a n-tuple of encoded data. The n refers to the length of
the record and there is no specific limit except that it must fit inside
the database memory segment (of course, the size is given as <code class="literal">wg_int</code>, the
universal datatype of WhiteDB, which itself has a maximum value, but this is
quite large, especially on a 64-bit system).</p><pre class="literallayout">void *rec = wg_create_record(db, 10);</pre><p>The datatype of the record is <code class="literal">void *</code>, just like the database handle. Now we
can use <code class="literal">rec</code> any time we need to do something with the record we’ve created.
By the way, the records do not all need to be the same size, so we could do</p><pre class="literallayout">void *rec2 = wg_create_record(db, 2);</pre><p>and have two records, one of them 10 fields and the other 2 fields in size.
However, the size is final and cannot be changed later.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_data_in_whitedb"></a>4.2. Data in WhiteDB</h3></div></div></div><p>An important distinction between WhiteDB and traditional databases is that
the user can and in some cases must pop the hood open and get their hands
dirty. Data encoding is one of such cases.</p><p>Everything inside the database is a "WhiteDB int", or a <code class="literal">wg_int</code> when we’re
writing C code. These are basically numbers (32-bit or 64-bit integers,
depending on your system), but for WhiteDB they contain encoded pieces of
information - type of a value and the value itself or some way to access the
value.</p><p>So whenever we need to write something, be it a string, a number or a date
to the database, first we have to encode it so that WhiteDB is ready to handle
it.</p><pre class="literallayout">wg_int enc = wg_encode_int(db, 443);
wg_int enc2 = wg_encode_str(db, "this is my string", NULL);</pre><p>The first line should be self-explanatory - <code class="literal">enc</code> is now 443 in WhiteDB’s
internal format. When encoding a string, be aware that the string itself
will be written to the database memory segment at that point - the encoded
value <code class="literal">enc2</code> will merely contain a reference to it. Also, there is a third
parameter which we can ignore for simple applications.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_setting_field_values"></a>4.3. Setting field values</h3></div></div></div><p>You may be asking yourself why do we need to bother with encoding the values
when we could simply write things like integers or character arrays directly.
The main reason for that is that WhiteDB is schemaless. When we created
records, we did not specify what type any of the fields were - they can be of
any type.  The encoded value is how WhiteDB can tell what type of data it is
dealing with, since field 1 could be an integer in one record, a
floating-point number in another one and so on.</p><p>With that out of the way, let’s take our encoded data and store it properly
in the database:</p><pre class="literallayout">wg_set_field(db, rec, 7, enc);
wg_set_field(db, rec2, 0, enc2);</pre><p>Field 7 of the first record now contains 443 and field 0 of the second record
(which has two fields, field 0 and field 1) contains "this is my string".</p><p>We didn’t touch any of the other fields and if we were to look at the
contents of the records now, these would be filled with NULL values. Each time
a new record is created, it initially contains a row of NULL-s which the user
can then overwrite with their own data.</p><p>Here is our complete example (<span class="emphasis"><em>Examples/tut2.c</em></span>):</p><pre class="programlisting">#include &lt;whitedb/dbapi.h&gt;

int main(int argc, char **argv) {
  void *db, *rec, *rec2;
  wg_int enc, enc2;

  db = wg_attach_database("1000", 2000000);
  rec = wg_create_record(db, 10);
  rec2 = wg_create_record(db, 2);

  enc = wg_encode_int(db, 443);
  enc2 = wg_encode_str(db, "this is my string", NULL);

  wg_set_field(db, rec, 7, enc);
  wg_set_field(db, rec2, 0, enc2);

  return 0;
}</pre><p>It is likely that you need to deal with more types than just strings and
integers. <a class="ulink" href="Manual.html" target="_top">The manual</a> will provide a full list of supported types.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_the_wgdb_utility"></a>5. The wgdb utility</h2></div></div></div><p>Once you’ve started working with WhiteDB, the <code class="literal">wgdb</code> tool may come in handy
to manage the databases, so let’s take a quick look at it. First we deal with
database persistence, you may skip to <a class="xref" href="#anchor-2" title="5.2. Looking at data">Section 5.2, “Looking at data”</a> if you’re not on
Windows.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_database_persistence_on_windows"></a>5.1. Database persistence on Windows</h3></div></div></div><p>The way shared memory works on Windows is that it is only present as long as
there is a program holding a handle to it. So when we compile and run the
previous example, the data gets written to the memory but then the program
terminates and the database immediately disappears. To get around that, run</p><pre class="literallayout">wgdb.exe 1000 server 2000000</pre><p>in another window. That will keep the shared memory present, until you press
CTRL+C. You can now run the tutorial programs and the following examples
should work.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="anchor-2"></a>5.2. Looking at data</h3></div></div></div><p>If you ran the program from the previous section, there should be some records
in memory now. Let’s take a look:</p><pre class="literallayout">wgdb 1000 select 20</pre><p>It should return something like this:</p><pre class="literallayout">[NULL,NULL,NULL,NULL,NULL,NULL,NULL,443,NULL,NULL]
["this is my string",NULL]</pre><p>The "1000" in the command is the same shared memory key we used earlier.
"select" prints records from the database and "20" limits the maximum number
of records that will be shown. There is also a query command that lets you
specify which records you are interested in:</p><pre class="literallayout">wgdb 1000 query 7 = 443</pre><p>That will only return the first record, the one where field 7 equals 443.
There are other comparison operators: "!=" for not equal, "&lt;" for less than,
"&lt;=" for less than or equal and so forth. Currently the query command does not
have a row limit parameter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_modifying_data"></a>5.3. Modifying data</h3></div></div></div><p>The command line tools allows some data manipulation: deleting and adding
records. The "del" command has the same syntax as the query command, so</p><pre class="literallayout">wgdb 1000 del 7 = 443</pre><p>will delete the first row from the database. We can also add records, but
only integer and string values are recognized this way - dealing with other
types unambiguously would become complicated.</p><pre class="literallayout">wgdb 1000 add 1 2 3</pre><p>This created a record with the length 3 and inserted three integer values
in it. Let’s see what the database now contains. By the way, since "1000" is
the default key, we may omit it:</p><pre class="literallayout">wgdb select 20</pre><p>The entire contents of the database will now be:</p><pre class="literallayout">["this is my string",NULL]
[1,2,3]</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_freeing_the_memory"></a>5.4. Freeing the memory</h3></div></div></div><p>At some point we may need to delete the database for whatever reason. The
<code class="literal">wgdb</code> tool will help:</p><pre class="literallayout">wgdb 1000 free</pre><p>The database with the given key will be freed. Again, "1000" may be omitted
as it is the default.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_making_queries"></a>6. Making queries</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_finding_matching_records"></a>6.1. Finding matching records</h3></div></div></div><p>Finding records that match some condition is easy:</p><pre class="literallayout">void *rec = wg_find_record_int(db, 7, WG_COND_EQUAL, 443, NULL);</pre><p>This returns the first record that has the integer 443 in field 7. That much
is obvious, but some of the parameters might need extra explanation.</p><p>First, just a reminder that <code class="literal">db</code> is the database handle we’ve been using
each time we call a WhiteDB function. As a second parameter we give the
number of the field that the database engine should check against the
value we’ve given.</p><p>The third parameter is the condition: we need some way of stating that we want
records where "field 7" "equals" "443" so that is the "equals" part. There are
other conditions, for example, if we substituted WG_COND_LESSTHAN there, we
would receive a record where the value in field 7 is less than 443. The full
list of possibe conditions is given in <a class="ulink" href="Manual.html" target="_top">the manual</a>.</p><p>The fourth parameter is, of course, the value. The function we called ended
with <span class="emphasis"><em>_int</em></span> and that parameter should also be of the type <code class="literal">int</code>. There is
a function for most of WhiteDB’s datatypes, so if we were looking for a
string we would use <code class="literal">wg_find_record_str()</code> instead.</p><p>Now let’s turn our attention to the mysterious NULL parameter. Remember
that our example function call returned the <span class="strong"><strong>first</strong></span> record that matched
our parameters? What if there are more matching records and we want to find
those too? That can be done:</p><pre class="literallayout">void *nextrec = wg_find_record_int(db, 7, WG_COND_EQUAL, 443, rec);</pre><p>Instead of the NULL, we can give the record that the function returned last
time and WhiteDB will return the next one that matches the same condition.</p><p>The following example will call <code class="literal">wg_find_record_int()</code> in a cycle, finding
all the matching record from the database. We’re adding some records, so it
will print "Found a record…" at least once. Run it multiple times and see
the number of matching records increase (<span class="emphasis"><em>Examples/tut3.c</em></span>):</p><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;whitedb/dbapi.h&gt;

int main(int argc, char **argv) {
  void *db, *rec;
  wg_int enc;

  db = wg_attach_database("1000", 2000000);

  /* create some records for testing */
  rec = wg_create_record(db, 10);
  enc = wg_encode_int(db, 443); /* will match */
  wg_set_field(db, rec, 7, enc);

  rec = wg_create_record(db, 10);
  enc = wg_encode_int(db, 442);
  wg_set_field(db, rec, 7, enc); /* will not match */

  /* now find the records that match our condition
   * "field 7 equals 443"
   */
  rec = wg_find_record_int(db, 7, WG_COND_EQUAL, 443, NULL);
  while(rec) {
    printf("Found a record where field 7 is 443\n");
    rec = wg_find_record_int(db, 7, WG_COND_EQUAL, 443, rec);
  }

  return 0;
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_full_query_interface"></a>6.2. Full query interface</h3></div></div></div><p>The above method of finding data is convinient, but it can be too limited
(and in some specific cases inefficient) so eventually we may need to make
use of full queries. The query API has a number of features we will not
be discussing here, instead we’ll look at only the basic steps.</p><p>Running a query in WhiteDB consists of preparing the argument list, creating
the query itself and then fetching the matching records from the query.</p><pre class="literallayout">wg_query_arg arglist[2];
arglist[0].column = 7;
arglist[0].cond = WG_COND_EQUAL;
arglist[0].value = wg_encode_query_param_int(db, 443);</pre><p>The <code class="literal">wg_query_arg</code> type is where we store one condition that the returned
records should match (or, a "clause" of the query, if you like more exact
terminology). Here we’ve specified again that we’d like to find records where
"field 7 equals 443".</p><p>Notice that we declared <code class="literal">arglist</code> as an array of 2 elements? Well, this is
because we can give more than one argument:</p><pre class="literallayout">arglist[1].column = 6;
arglist[1].cond = WG_COND_EQUAL;
arglist[1].value = wg_encode_query_param_null(db, NULL);</pre><p>Now we’re looking for records where "field 7 equals 443 and field 6 equals
NULL". The value for both arguments is encoded and it’s recommended to use the
special <code class="literal">wg_encode_query_param_*()</code> functions for that purpose.</p><pre class="literallayout">wg_query *query = wg_make_query(db, NULL, 0, arglist, 2);</pre><p>We pass the argument list and it’s size, which is 2, to WhiteDB (ignore the
other parameters for now, they’re not used if you use the argument list).
We receive a query object in return and are finally ready to start fetching
records:</p><pre class="literallayout">void *rec = wg_fetch(db, query);</pre><p>The <code class="literal">wg_fetch()</code> function will return a different record each time you call it
and eventually it will return NULL, meaning that you’ve already fetched all
the records that match our argument list. Finally we should do some
housekeeping, as queries may take up quite a bit of memory:</p><pre class="literallayout">wg_free_query(db, query);
wg_free_query_param(db, arglist[0].value);
wg_free_query_param(db, arglist[1].value);</pre><p>That was quite a bit of work to do essentialy the same thing we achieved
with the help of just one function earlier, but it will also give you more
power and flexibility. The following program (<span class="emphasis"><em>Examples/tut4.c</em></span>) summarizes
what we’ve looked at here:</p><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;whitedb/dbapi.h&gt;

int main(int argc, char **argv) {
  void *db, *rec;
  wg_int enc;
  wg_query_arg arglist[2]; /* holds the arguments to the query */
  wg_query *query;         /* used to fetch the query results */

  db = wg_attach_database("1000", 2000000);

  /* just in case, create some records for testing */
  rec = wg_create_record(db, 10);
  enc = wg_encode_int(db, 443); /* will match */
  wg_set_field(db, rec, 7, enc);

  rec = wg_create_record(db, 10);
  enc = wg_encode_int(db, 442);
  wg_set_field(db, rec, 7, enc); /* will not match */

  /* now find the records that match the condition
   * "field 7 equals 443 and field 6 equals NULL". The
   * second part is a bit redundant but we're adding it
   * to show the use of the argument list.
   */
  arglist[0].column = 7;
  arglist[0].cond = WG_COND_EQUAL;
  arglist[0].value = wg_encode_query_param_int(db, 443);

  arglist[1].column = 6;
  arglist[1].cond = WG_COND_EQUAL;
  arglist[1].value = wg_encode_query_param_null(db, NULL);

  query = wg_make_query(db, NULL, 0, arglist, 2);

  while((rec = wg_fetch(db, query))) {
    printf("Found a record where field 7 is 443 and field 6 is NULL\n");
  }

  /* Free the memory allocated for the query */
  wg_free_query(db, query);
  wg_free_query_param(db, arglist[0].value);
  wg_free_query_param(db, arglist[1].value);
  return 0;
}</pre><p>You may run this program a couple of times, then run <code class="literal">wgdb select 20</code> to
verify that the tutorial program prints the correct number of rows.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_doing_things_properly"></a>7. Doing things properly</h2></div></div></div><p>The examples we’ve been following up to now have been a bit sloppy. We haven’t
bothered to check whether the WhiteDB functions fail or succeed, nor to clean
up after after we were done - there was only the bit about freeing queries
which was just too important to ignore.</p><p>First thing you should consider is that attaching to a database can sometimes
fail. For example, it is possible that you requested more shared memory than
the system configuration allows. So do a check like this:</p><pre class="literallayout">void *db = wg_attach_database("1000", 1000000);
if(db == NULL) { /* do something to handle the error */ }</pre><p>Creating records or encoding data can fail if the database is full - actually
a common occurence since memory databases are naturally smaller than the
traditional disk-based ones.</p><pre class="literallayout">void *rec = wg_create_record(db, 1000);
if(rec == NULL) { /* record was not created, can't use it */ }</pre><pre class="literallayout">wg_int enc = wg_encode_str(db, "This could fail", NULL);
if(enc == WG_ILLEGAL) { /* string encoding failed */ }</pre><p>Notice the WG_ILLEGAL value? This is a special encoded value that WhiteDB uses
to tell you that something went wrong. All <code class="literal">wg_encode_*()</code> functions return
that so it is easy to check for encode errors.</p><p>Decoding values can also fail. The most obvious case is when you expect some
field in a record to be of a certain type, but some other program or user has
written a different value there. This can sometimes be tricky to detect
so you should consult the <a class="ulink" href="Manual.html" target="_top">Manual</a> how a particular <code class="literal">wg_decode_*()</code>
function behaves.</p><p>If the database is used in a way that makes it difficult to predict what
type of data a field contains, there is a way to find out:</p><pre class="literallayout">if(wg_get_field_type(db, rec, 0)) == WG_STRTYPE) {
  printf("Field 0 in rec is a string\n");
}</pre><p>Finally, here’s something that is nice to do whenever a program stops using
a database:</p><pre class="literallayout">wg_detach_database(db);</pre><p>This detaches us from the shared memory and also frees any memory that may
be allocated for the database handle.</p><p>Let’s try to apply all of those things in practice (<span class="emphasis"><em>Examples/tut5.c</em></span>). The
program creates records in a loop and writes a short string value in each
of them. We have a small database, so soon we’ll run out of space, causing
some errors which we are now able to cope with:</p><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;whitedb/dbapi.h&gt;

int main(int argc, char **argv) {
  void *db, *rec, *lastrec;
  wg_int enc;
  int i;

  db = wg_attach_database("1000", 1000000); /* 1MB should fill up fast */
  if(!db) {
    printf("ERR: Could not attach to database.\n");
    exit(1);
  }

  lastrec = NULL;
  for(i=0;;i++) {
    char buf[20];
    rec = wg_create_record(db, 1);
    if(!rec) {
      printf("ERR: Failed to create a record (made %d so far)\n", i);
      break;
    }
    lastrec = rec;
    sprintf(buf, "%d", i); /* better to use snprintf() in real applications */
    enc = wg_encode_str(db, buf, NULL);
    if(enc == WG_ILLEGAL) {
      printf("ERR: Failed to encode a string (%d records currently)\n", i+1);
      break;
    }
    if(wg_set_field(db, rec, 0, enc)) {
      printf("ERR: This error is less likely, but wg_set_field() failed.\n");
      break;
    }
  }

  /* For educational purposes, let's pretend we're interested in what's
   * stored in the last record.
   */
  if(lastrec) {
    char *str = wg_decode_str(db, wg_get_field(db, lastrec, 0));
    if(!str) {
      printf("ERR: Decoding the string field failed.\n");
      if(wg_get_field_type(db, lastrec, 0) != WG_STRTYPE) {
        printf("ERR: The field type is not string - "
          "should have checked that first!\n");
      }
    }
  }

  wg_detach_database(db);
  return 0;
}</pre><p>To try this out, let’s first try to cause an error on attaching. Type these
commands:</p><pre class="literallayout">wgdb free
wgdb create 999999</pre><p>Then run the example program. Since we’ve already created a database and it’s
smaller than what the progam is requesting, it should complain and exit early.
When done with this, type <code class="literal">wgdb free</code> again to delete the smaller database.
Run the example program again, this time there is nothing in the way so it
can create the database named "1000" itself.</p><p>The results can be a bit unpredictable, but you should either see a record
creation error or a number of errors related to a string field. Of course,
this does not mean that the program failed or did nothing useful - a number
of records were created successfully, we just eventually ran out of database
space. Everything our program printed has "ERR:" in front of it - the rest
of the messages come from WhiteDB.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_parallel_use"></a>8. Parallel use</h2></div></div></div><p>WhiteDB never locks the database for you. Whenever something is read or
written, the engine just goes and does it without checking whether some other
program (or user) is currently using the database. This goes with the
philosophy of speed and simplicity.</p><p>But there are many use cases where parallel use of the database is needed and
in those cases everybody cannot just crowd the database at the same time and
start making changes to the shared memory area - that could result in
inconsistent data, or worse, a corrupt and useless database. Fortunately,
WhiteDB does provide the user with the tools to handle that.</p><p>The rule of thumb is that you need these concurrency control functions
whenever the database is <span class="strong"><strong>both read and written</strong></span> by several processes and
possibly at the same time. For example, if a database is serving data to
a webserver and there are occasional updates to the data (without shutting
down the webserver), that would qualify as needing concurrency control.</p><p>To implement this concurrency control, we first request permission to read
whenever we are about to read something from the database and similarly
declare our intention to write to the database. Once we’re done we inform
the database engine that we’re finished so others may proceed. So,</p><pre class="literallayout">wg_int lock_id = wg_start_read(db);
/* do some reading */
wg_end_read(db, lock_id);</pre><p>requests permission to read. There may be some time until the function
<code class="literal">wg_start_read()</code> returns - it may need to wait for some other process to
finish whatever it is doing with the database. Once it returns the <code class="literal">lock_id</code>,
we have shared access to the database - we may read it safely and so may
other processes, but no one can write anything. <code class="literal">wg_end_read()</code> declares
that we no longer need the read access.</p><p>It is quite possible that <code class="literal">wg_start_read()</code> fails - it can happen under heavy
load or if some other process is hogging the database for a long time. We
should always check:</p><pre class="literallayout">lock_id = wg_start_read(db);
if(!lock_id) {
  printf("wg_start_read() timed out\n");
  exit(1); /* or go and retry, whatever is appropriate */
}</pre><p>Getting write access is similar, the major difference is that once we get
the permission, we have exclusive access - everyone else has to wait until
we’re done adding or updating the data:</p><pre class="literallayout">lock_id = wg_start_write(db);
if(!lock_id) {
  printf("wg_start_write() timed out\n");
  exit(1);
}
/* do some writing */
wg_end_write(db, lock_id);</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>At present time these functions behave exactly like operating on a
single big database-level lock. This tutorial does not make a secret of it,
however, the future direction may be that they start behaving more like
transactions. The important thing to remember is that the purpose is to allow
you to read and write data safely, without corruption and inconsistency. By
following the pattern described here, your program will continue to work
unmodified, no matter how WhiteDB implements things internally.</p></td></tr></table></div><p>To illustrate parallel use, we will implement a counter that is incremented
from two programs simultaneously. This kind of example is frequently used
in parallel programming tutorials, when done naively the counter counts
incorrectly because the processes end up ignoring some of the increments done
by the other process. We will place this counter value inside a WhiteDB
database (<span class="emphasis"><em>Examples/tut6.c</em></span>).</p><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;whitedb/dbapi.h&gt;

#define NUM_INCREMENTS 100000

void die(void *db, int err) {
  wg_detach_database(db);
  exit(err);
}

int main(int argc, char **argv) {
  void *db, *rec;
  wg_int lock_id;
  int i, val;

  if(!(db = wg_attach_database("1000", 1000000))) {
    exit(1); /* failed to attach */
  }

  /* First we need to make sure both counting programs start at the
   * same time (otherwise the example would be boring).
   */
  lock_id = wg_start_read(db);
  rec = wg_get_first_record(db); /* our database only contains one record,
                                  * so we don't need to make a query.
                                  */
  wg_end_read(db, lock_id);

  if(!rec) {
    /* There is no record yet, we're the first to run and have
     * to set up the counter.
     */
    lock_id = wg_start_write(db);
    if(!lock_id) die(db, 2);
    rec = wg_create_record(db, 1);
    wg_end_write(db, lock_id);

    if(!rec) die(db, 3);
    printf("Press a key when all the counter programs have been started.");
    fgetc(stdin);

    /* Setting the counter to 0 lets each counting program know it can
     * start counting now.
     */
    lock_id = wg_start_write(db);
    if(!lock_id) die(db, 2);
    wg_set_field(db, rec, 0, wg_encode_int(db, 0));
    wg_end_write(db, lock_id);
  } else {
    /* Some other program has started first, we wait until the counter
     * is ready.
     */
    int ready = 0;

    while(!ready) {
      lock_id = wg_start_read(db);
      if(!lock_id) die(db, 2);
      if(wg_get_field_type(db, rec, 0) == WG_INTTYPE)
        ready = 1;
      wg_end_read(db, lock_id);
    }
  }

  /* Now start the actual counting. */
  for(i=0; i&lt;NUM_INCREMENTS; i++) {
    lock_id = wg_start_write(db);
    if(!lock_id) die(db, 2);

    /* This is the "critical section" for the counter. we read the value,
     * increment it and write it back.
     */
    val = wg_decode_int(db, wg_get_field(db, rec, 0));
    wg_set_field(db, rec, 0, wg_encode_int(db, ++val));

    wg_end_write(db, lock_id);
  }

  printf("\nCounting done. My last value was %d\n", val);
  return 0;
}</pre><p>Before running the program, type <code class="literal">wgdb free</code>. We’ve tried to keep the example
as simple as possible, so it needs a completely empty database to start. Next
start the program in one window; it will prompt you to press a key. Now go
to another window and start the program one more time - this one will just
wait and do nothing.</p><p>Both programs are now ready to start counting, but the first program is
waiting for a key press and the second one is waiting for the counter to get
it’s initial value. Go back to the first window and press a key. The counter
will be initialized and both programs proceed to increment it 100000 times.
Type <code class="literal">wgdb select 1</code> to check what the value of the counter is - it should be
200000.</p><p>If those programs were for different sensors in a real-life program, counting
some event, we would have managed to get the correct number of events in the
end.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_network_database"></a>9. Network database</h2></div></div></div><p>If you can picture the content of a WhiteDB database, there isn’t necessarily
much structure there - just many, many records which may be of different
sizes. Because you can query records by the field contents, the fields
can be thought of as columns and the entire database as a flat table where
the records form the rows.</p><p>To fit any kind of data model in WhiteDB, the user needs to create the
structure themselves. Carrying over the RDBMS mindset and creating, for
example <span class="emphasis"><em>employee</em></span>, <span class="emphasis"><em>address</em></span> and <span class="emphasis"><em>customer</em></span> records, which can be referred
to by some id field, would certainly work, but there is another way.</p><p>Before there were relational databases, there was the network model. It is
a fairly simple concept where instead of referring to to something by key, you
include it directly: if I want to add an address to a customer, I just insert
the address into the customer record. The difference may seem superficial, but
the underlying mechanics are very different.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_record_linking_in_whitedb"></a>9.1. Record linking in WhiteDB</h3></div></div></div><p>WhiteDB implements the network model in a straightforward way. This tutorial
has already shown how to write an integer or a string into a field inside
a record, putting another record there works exactly the same:</p><pre class="literallayout">void *rec = wg_create_record(db, 2); /* this is some record */
void *rec2 = wg_create_record(db, 3); /* this is another record */
wg_int enc = wg_encode_record(db, rec);  /* encode as a WhiteDB value */
wg_set_field(db, rec, 1, wg_encode_str(db, "hello", NULL));
wg_set_field(db, rec2, 2, enc);</pre><p>Assuming we don’t add any other fields, the first record now looks like this:
<code class="literal">[NULL, "hello"]</code>. But the second one is more interesting: <code class="literal">[NULL, NULL,
[NULL, "hello"]]</code>. Of course, the data isn’t actually duplicated inside the
second record, its field 2 just contains a reference. But if your program
already holds <code class="literal">rec2</code>, getting to the contents of <code class="literal">rec</code> is very fast.</p><p>So how does one make use of such data? If I have the second record, I can
get to the message inside the first record like this (checking for the
type isn’t mandatory of course, this is just to show that the record is
a datatype just like an integer or a double):</p><pre class="literallayout">if(wg_get_field_type(db, rec2, 2) == WG_RECORDTYPE) {
  void *rec = wg_decode_record(db, wg_get_field(db, rec2, 2));
  char *message = wg_decode_str(db, wg_get_field(db, rec, 1));
  /* we find that the message is "hello" */
}</pre><p>Linking records together can produce a graph, a tree or whatever is needed.
Or we can treat the records as containing other records inside, so our
initial view of them as flat table rows was a bit deceptive and a set would
perhaps be a more accurate description.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>A field containing a reference to a record isn’t different from other
fields. It can still be indexed and you could write a query like "give me
a record where field 3 is [ "owner", [ "name", "Peter", "age", 25 ]]" and
it would work. However, while record references are fast, keeping track of
such recursion can be expensive so it is best to avoid deep chains of records
on indexed fields.</p></td></tr></table></div><p>The next program (<span class="emphasis"><em>Examples/tut7.c</em></span>) creates some records and links them
together. Run it, then use <code class="literal">wgdb select 20</code> to examine the database contents.
The records will appear nested inside each other:</p><pre class="programlisting">#include &lt;stdlib.h&gt;
#include &lt;whitedb/dbapi.h&gt;

int main(int argc, char **argv) {
  void *db, *rec, *rec2, *rec3;
  wg_int enc;

  if(!(db = wg_attach_database("1000", 2000000)))
    exit(1); /* failed to attach */

  rec = wg_create_record(db, 2); /* this is some record */
  rec2 = wg_create_record(db, 3); /* this is another record */
  rec3 = wg_create_record(db, 4); /* this is a third record */

  if(!rec || !rec2 || !rec3)
    exit(2);

  /* Add some content */
  wg_set_field(db, rec, 1, wg_encode_str(db, "hello", NULL));
  wg_set_field(db, rec2, 0, wg_encode_str(db,
    "I'm pointing to other records", NULL));
  wg_set_field(db, rec3, 0, wg_encode_str(db,
    "I'm linked from two records", NULL));

  /* link the records to each other */
  enc = wg_encode_record(db, rec);
  wg_set_field(db, rec2, 2, enc); /* rec2[2] points to rec */
  enc = wg_encode_record(db, rec3);
  wg_set_field(db, rec2, 1, enc); /* rec2[1] points to rec3 */
  wg_set_field(db, rec, 0, enc); /* rec[0] points to rec3 */

  wg_detach_database(db);
  return 0;
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_when_to_use_the_network_model"></a>9.2. When to use the network model</h3></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>the code included in this section isn’t here to show you how to do
things but rather to illustrate what would happen if things <span class="strong"><strong>were</strong></span> done this
way.</p></td></tr></table></div><p>Consider our earlier example with two records, one of them containing the
important message "hello". Let’s try to use techniques that work in relational
databases to accomplish the same thing. Storing the data isn’t complicated:</p><pre class="literallayout">void *rec = wg_create_record(db, 2);
void *rec2 = wg_create_record(db, 3);
wg_int hello_id = wg_encode_int(db, 11913); /* an arbitrary record id */
wg_set_field(db, rec, 0, hello_id); /* assign the id */
wg_set_field(db, rec, 1, wg_encode_str(db, "hello", NULL));
wg_set_field(db, rec2, 2, hello_id); /* reference by id */</pre><p>So far so good. The records should now contain <code class="literal">[11913, "hello"]</code> and <code class="literal">[NULL,
NULL, 11913]</code>. Pretend again that we have just the <code class="literal">rec2</code> (as a result of a
query, for example) and need the contents of <code class="literal">rec</code>:</p><pre class="literallayout">int hello_id = wg_decode_int(db, wg_get_field(db, rec2, 2));
/* this will search the database for 11913 */
void *rec = wg_find_record_int(db, 0, WG_COND_EQUAL, hello_id, NULL);
char *message = wg_decode_str(db, wg_get_field(db, rec, 1));</pre><p>If you have an index on field 0, this doesn’t look that bad. Sure, the value
"11913" needs to be looked up, but <code class="literal">wg_find_record_int()</code> can manage it
reasonably fast. What if you had to do this inside a loop, though? How about
a nested loop? Executing a million queries isn’t that fun anymore, even if
they don’t take up time individually - <code class="literal">wg_decode_record()</code> would have taken
a fraction of that.</p><p>The lesson to learn from here is that whenever you have a data model where
objects have relations to each other and need to perform JOIN type queries
on them, it can be much faster in WhiteDB to implement the "join" in advance
by linking the object records to each other. Those links can then be navigated
rapidly to collect all the data.</p><p>Another use case is storing semi-structured data. We have used the network
model in our implementation of JSON documents in WhiteDB (a work in progress)
where for example an array can contain other arrays or objects: the record
linking feature allows us to accomplish this elegantly by making the array
a record whose fields contain links to other records holding the child
elements.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_more_examples"></a>10. More examples</h2></div></div></div><p>There are a few more examples distributed with WhiteDB that were not covered
in this tutorial. You may look at <span class="emphasis"><em>Examples/demo.c</em></span> and <span class="emphasis"><em>Examples/query.c</em></span> that
should be commented well enough to be understandable by now.</p><p>Examples in Examples/speed are geared towards speed testing and are covered
in <a class="ulink" href="http://whitedb.org/speed.html" target="_top">http://whitedb.org/speed.html</a></p><p>A bit more involved example to look at is <span class="emphasis"><em>Server/dserve.c</em></span>: making queries
from WhiteDB with a simple REST cgi program giving json or csv output.
<code class="literal">dserve</code> is useful both as it is and as an example/template for making your own
tools for WhiteDB data handling: see <a class="ulink" href="http://whitedb.org/tools.html" target="_top">http://whitedb.org/tools.html</a></p></div></div></body></html>